#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% Linkfläche für Querverweise vergrößern und automatisch benenne
\AtBeginDocument{\renewcommand{\ref}[1]{\mbox{\autoref{#1}}}}
\newlength{\abc}
\settowidth{\abc}{\space}
\AtBeginDocument{%
\addto\extrasngerman{
 \renewcommand{\equationautorefname}{\hspace{-\abc}}
 \renewcommand{\sectionautorefname}{Kap.\negthinspace}
 \renewcommand{\subsectionautorefname}{Kap.\negthinspace}
 \renewcommand{\subsubsectionautorefname}{Kap.\negthinspace}
 \renewcommand{\figureautorefname}{Abb.\negthinspace}
 \renewcommand{\tableautorefname}{Tab.\negthinspace}
}
}

% für den Fall, dass jemand die Bezeichnung "Gleichung" haben will
%\renewcommand{\eqref}[1]{Gleichung~(\negthinspace\autoref{#1})}

% Setzt den Link für Sprünge zu Gleitabbildungen
% auf den Anfang des Gelitobjekts und nicht aufs Ende
\usepackage[figure]{hypcap}

% Die Seiten des Inhaltsverzeichnisses werden römisch numeriert,
% ein PDF-Lesezeichen für das Inhaltsverzeichnis wird hinzugefügt
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% make caption labels bold
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enable calculations
\usepackage{calc}

% fancy page header/footer settings
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

%Vergrößert den Teil der Seite, in dem Gleitobjekte
% unten angeordnet werden dürfen
\renewcommand{\bottomfraction}{0.5}

% Vermeidet, dass Gleitobjekte vor ihrem Abschnitt gedruckt werden
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage,fleqn
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
\end_modules
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Apéndice"
\pdf_author "Elena Coronel, Diego Ramírez, Koichi Oguro, Ariel Méndez"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Anexos
\end_layout

\begin_layout Section
Código
\end_layout

\begin_layout Subsection
coldaemon (Script)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=sh,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "$1" in
\end_layout

\begin_layout Plain Layout

start)
\end_layout

\begin_layout Plain Layout

echo "Iniciando servicio...
 "
\end_layout

\begin_layout Plain Layout

# Aquí comando a ejecutar para arrancar el servicio
\end_layout

\begin_layout Plain Layout

	cold /etc/cold.properties
\end_layout

\begin_layout Plain Layout

;;
\end_layout

\begin_layout Plain Layout

stop)
\end_layout

\begin_layout Plain Layout

# Aquí comando a ejecutar para detener el servicio
\end_layout

\begin_layout Plain Layout

	pid=`pidof cold`
\end_layout

\begin_layout Plain Layout

	if [ -z $pid ]; then        
\end_layout

\begin_layout Plain Layout

		echo "No se puede detener el servicio, el demonio no esta corriendo"
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		echo "Deteniendo servicio..."
\end_layout

\begin_layout Plain Layout

		kill -TERM $pid
\end_layout

\begin_layout Plain Layout

	fi
\end_layout

\begin_layout Plain Layout

#TERM (15) senhal de detenerse
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

;;
\end_layout

\begin_layout Plain Layout

restart)
\end_layout

\begin_layout Plain Layout

# Aquí comando a ejecutar para reiniciar el servicio
\end_layout

\begin_layout Plain Layout

	pid=`pidof cold`
\end_layout

\begin_layout Plain Layout

	if [ -z $pid ]; then        
\end_layout

\begin_layout Plain Layout

		echo "No se puede reiniciar el servicio, el demonio no esta corriendo"	
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		echo "Reiniciando servicio..."
\end_layout

\begin_layout Plain Layout

		kill -TERM $pid
\end_layout

\begin_layout Plain Layout

		sleep 3
\end_layout

\begin_layout Plain Layout

		cold /etc/cold.properties
\end_layout

\begin_layout Plain Layout

	fi
\end_layout

\begin_layout Plain Layout

#TERM (15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

;;
\end_layout

\begin_layout Plain Layout

reload)
\end_layout

\begin_layout Plain Layout

# Aquí comando a ejecutar para recargar el servicio
\end_layout

\begin_layout Plain Layout

	pid=`pidof cold`
\end_layout

\begin_layout Plain Layout

	if [ -z $pid ]; then 
\end_layout

\begin_layout Plain Layout

		echo "No se puede recargar..
 el demonio no esta corriendo.."
\end_layout

\begin_layout Plain Layout

	else 
\end_layout

\begin_layout Plain Layout

		echo "Recargando archivo de configuracion del servicio..."	
\end_layout

\begin_layout Plain Layout

		kill -HUP $pid
\end_layout

\begin_layout Plain Layout

	fi
\end_layout

\begin_layout Plain Layout

	#HUP (1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

;;
\end_layout

\begin_layout Plain Layout

status)
\end_layout

\begin_layout Plain Layout

	pid=`pidof cold`
\end_layout

\begin_layout Plain Layout

	if [ -z $pid ]; then
\end_layout

\begin_layout Plain Layout

		echo "El demonio no esta activo.."
\end_layout

\begin_layout Plain Layout

	else
\end_layout

\begin_layout Plain Layout

		echo "El demonio esta activo PID= $pid"
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	fi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

;;
\end_layout

\begin_layout Plain Layout

*)
\end_layout

\begin_layout Plain Layout

echo "Modo de empleo: sudo service coldaemon {start|stop|restart|reload|status}"
\end_layout

\begin_layout Plain Layout

exit 1
\end_layout

\begin_layout Plain Layout

;;
\end_layout

\begin_layout Plain Layout

esac
\end_layout

\begin_layout Plain Layout

exit 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
coldaemon.h
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#include <sys/types.h>
\end_layout

\begin_layout Plain Layout

#include <sys/stat.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <fcntl.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

#include <time.h>
\end_layout

\begin_layout Plain Layout

#include <syslog.h>
\end_layout

\begin_layout Plain Layout

#include <signal.h>
\end_layout

\begin_layout Plain Layout

#include <sys/socket.h>
\end_layout

\begin_layout Plain Layout

#include <netinet/in.h>
\end_layout

\begin_layout Plain Layout

#include <arpa/inet.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <postgresql/libpq-fe.h>
\end_layout

\begin_layout Plain Layout

//#include <netbd.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Todas las variables en minúsculas, se usa guion bajo si es necesario
\end_layout

\begin_layout Plain Layout

	ej; var, var_muy_larga
\end_layout

\begin_layout Plain Layout

	Todos los define en mayúsculas
\end_layout

\begin_layout Plain Layout

	ej: #define MACRO valor_macro
\end_layout

\begin_layout Plain Layout

	todos los nombres de función en minúsculas
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Definiciones
\end_layout

\begin_layout Plain Layout

#define STR_LEN 512
\end_layout

\begin_layout Plain Layout

#define PKG_LEN 16384
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Estructuras de datos
\end_layout

\begin_layout Plain Layout

struct thread_list
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	pthread_t hilo;
\end_layout

\begin_layout Plain Layout

	int thread_index;
\end_layout

\begin_layout Plain Layout

	struct thread_list * siguiente;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef struct
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int threads; // cantidad de hilos (thread manager)
\end_layout

\begin_layout Plain Layout

	int puerto; // puerto de escucha
\end_layout

\begin_layout Plain Layout

	char acl[STR_LEN]; // lista de control de acceso
\end_layout

\begin_layout Plain Layout

	char log[STR_LEN]; // bitácora del demonio
\end_layout

\begin_layout Plain Layout

	int timeout; // tiempo límite de espera
\end_layout

\begin_layout Plain Layout

	struct thread_list * lista_hilo; // hilos en ejecución
\end_layout

\begin_layout Plain Layout

	int thread_index; // identificador de hilo (thread worker)
\end_layout

\begin_layout Plain Layout

	int socket_descriptor; // descriptor de socket (thread worker)
\end_layout

\begin_layout Plain Layout

	struct sockaddr_in socket; // estructura socket (thread worker)
\end_layout

\begin_layout Plain Layout

} thread_arg;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct parameters
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	thread_arg arg;
\end_layout

\begin_layout Plain Layout

	struct parameters * siguiente;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

typedef struct 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	char *codser; //3 DIGITOS codigo de servicio
\end_layout

\begin_layout Plain Layout

	int numtran; //6 DIGITOS numero de transaccion
\end_layout

\begin_layout Plain Layout

	char *fechahora; //14 DIGITOS fecha y hora de transaccion
\end_layout

\begin_layout Plain Layout

	char *tipofact; // 3 DIGITOS tipo de factura
\end_layout

\begin_layout Plain Layout

	char *comprobante; //11 DIGITOS numero de comprobante
\end_layout

\begin_layout Plain Layout

	long int monto; //12 DIGITOS monto de la factura
\end_layout

\begin_layout Plain Layout

	char *vencimiento; //8 DIGITOS fecha de vencimiento
\end_layout

\begin_layout Plain Layout

	int verificador; //1 DIGITOS digito verificador
\end_layout

\begin_layout Plain Layout

	char *prefijo; //4 DIGITOS prefijo
\end_layout

\begin_layout Plain Layout

	char *numero; //7 DIGITOS numero telefonico
\end_layout

\begin_layout Plain Layout

	char *nummed; //15 DIGITOS numero de medidor
\end_layout

\begin_layout Plain Layout

	char *abonado; //9 DIGITOS numero de abonado
\end_layout

\begin_layout Plain Layout

	char *mensaje; //20 CARACTERES DE MENSAJE
\end_layout

\begin_layout Plain Layout

}SERVICIO;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int ready;
\end_layout

\begin_layout Plain Layout

pthread_mutex_t lock;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Biblioteca de Funciones de:
\end_layout

\begin_layout Plain Layout

// Hash, postgres, semaforos
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define OK 0
\end_layout

\begin_layout Plain Layout

#define ARGUMENTOS_INVALIDOS 1
\end_layout

\begin_layout Plain Layout

#define NO_CONFIG_FILE 2
\end_layout

\begin_layout Plain Layout

#define INVALID_CONFIG_FILE 3
\end_layout

\begin_layout Plain Layout

#define CANT_OPEN_ACL 13
\end_layout

\begin_layout Plain Layout

#define LOG_ERROR 11
\end_layout

\begin_layout Plain Layout

#define SOCK_DESCRIPTOR_ERROR 4
\end_layout

\begin_layout Plain Layout

#define BINDING_ERROR 5 
\end_layout

\begin_layout Plain Layout

#define LISTENNING_ERROR 6
\end_layout

\begin_layout Plain Layout

#define ACCEPT_CONNECTION_ERROR 7
\end_layout

\begin_layout Plain Layout

#define CANT_FORK 8
\end_layout

\begin_layout Plain Layout

#define SESSION_ERROR 9
\end_layout

\begin_layout Plain Layout

#define CHDIR_ERROR 10
\end_layout

\begin_layout Plain Layout

#define CONFIG_ERROR 12
\end_layout

\begin_layout Plain Layout

#define NULL_THREAD 14
\end_layout

\begin_layout Plain Layout

#define CANT_CLOSE_SOCKET 15
\end_layout

\begin_layout Plain Layout

#define DB_EXIT_NICELY 20
\end_layout

\begin_layout Plain Layout

#define CANT_READ_ACL 16
\end_layout

\begin_layout Plain Layout

#define INVALID_USER 17
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define INVALID_COD_SERV 30
\end_layout

\begin_layout Plain Layout

#define INVALID_YEAR 31
\end_layout

\begin_layout Plain Layout

#define INVALID_DAY 32
\end_layout

\begin_layout Plain Layout

#define INVALID_MONTH 33
\end_layout

\begin_layout Plain Layout

#define INVALID_HOUR 34
\end_layout

\begin_layout Plain Layout

#define INVALID_MIN 35
\end_layout

\begin_layout Plain Layout

#define INVALID_SEC 36
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	acl_file es un puntero al nombre del fichero que tiene los datos de autenticaci
ón
\end_layout

\begin_layout Plain Layout

	usuario es un puntero al nombre usuario
\end_layout

\begin_layout Plain Layout

	clave es un puntero a la clave
\end_layout

\begin_layout Plain Layout

	la función retorna 0 si la autenticación es exitosa y se debe definir códigos
 
\end_layout

\begin_layout Plain Layout

	de error para cada caso de error
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

//char authentication(char * acl_file, char * usuario, char * clave);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	config_parser lee un archivo de configuración y establece los parámetros
 del demonio a partir del mismo
\end_layout

\begin_layout Plain Layout

	retorna 0 si no hubo errores, establecer sus códigos de error en otro caso
\end_layout

\begin_layout Plain Layout

	config_file, puntero al nombre del archivo de configuración
\end_layout

\begin_layout Plain Layout

	puerto, threads, timeout, logpath, logfile, parámetros del demonio.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

int config_parser (char * config_file, int * puerto, int * threads, int
 * timeout, char ** logpath, char ** logfile, char ** aclpath, char ** aclfile);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	EL CORE DAEMON
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

void * coredaemon(void * argumento);
\end_layout

\begin_layout Plain Layout

// Helper para limpiar el #015 que telnet envía como Retorno de Línea
\end_layout

\begin_layout Plain Layout

void limpiar_telnet(char * cadena);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	Parser de patrones de entrada
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

char col_parser (SERVICIO *servicio, char * patron, int log_fd);
\end_layout

\begin_layout Plain Layout

char rev_parser (SERVICIO *reversa, char * patron);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	Módulo de Base de Datos
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

int db_module(char * operacion, SERVICIO serv, char * usuario, int log_fd,
 char * resp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	UTILERIA GENERAL
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

void writelog(int log_fd, const char * mensaje);
\end_layout

\begin_layout Plain Layout

void thread_add(struct thread_list **lista, int index);
\end_layout

\begin_layout Plain Layout

pthread_t * thread_get(struct thread_list *lista, int index);
\end_layout

\begin_layout Plain Layout

void thread_del(struct thread_list **lista, int index);
\end_layout

\begin_layout Plain Layout

uint32_t hash( char * str);
\end_layout

\begin_layout Plain Layout

char authentication (char * acl_file, char * user, uint32_t pass_buscado);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	Administrador de Hilos
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

void * thread_manager(void * argumento);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

	Módulo de Configuración
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

char config_module(char * config_file, thread_arg * argumento);
\end_layout

\begin_layout Plain Layout

void dbg_print_thread_arg(thread_arg * argumento);
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
coldaemon.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

#include <pthread.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char * argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	char * config_file;
\end_layout

\begin_layout Plain Layout

	pid_t pid, sid;
\end_layout

\begin_layout Plain Layout

	char * logpath;
\end_layout

\begin_layout Plain Layout

	char * logfile;
\end_layout

\begin_layout Plain Layout

	char * aclpath;
\end_layout

\begin_layout Plain Layout

	char * aclfile;
\end_layout

\begin_layout Plain Layout

	char buf[PKG_LEN];
\end_layout

\begin_layout Plain Layout

	char printBuffer[STR_LEN];
\end_layout

\begin_layout Plain Layout

	int i, len, log_fd, ret, j;
\end_layout

\begin_layout Plain Layout

	int socket_descriptor;
\end_layout

\begin_layout Plain Layout

	pthread_t manager;
\end_layout

\begin_layout Plain Layout

	thread_arg  argumento;
\end_layout

\begin_layout Plain Layout

	int create_thread_value;
\end_layout

\begin_layout Plain Layout

	char flag_asignado_hilo;
\end_layout

\begin_layout Plain Layout

	struct sockaddr_in sin;
\end_layout

\begin_layout Plain Layout

	FILE * temp_file;
\end_layout

\begin_layout Plain Layout

	ready = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Validación de Argumentos, debe haber un argumento que especifique
\end_layout

\begin_layout Plain Layout

	// el fichero de configuración del demonio
\end_layout

\begin_layout Plain Layout

	if(argc != 2)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"Se necesita el fichero de configuración
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return ARGUMENTOS_INVALIDOS;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// fichero de configuración de los parámetros del demonio
\end_layout

\begin_layout Plain Layout

	config_file = argv[1];
\end_layout

\begin_layout Plain Layout

	// MODULO DE CONFIGURACION	
\end_layout

\begin_layout Plain Layout

	if( (ret = config_module(config_file, &argumento)) != 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"Error con los parámetros de configuración config_module
\backslash
n",ret);
\end_layout

\begin_layout Plain Layout

		return CONFIG_ERROR;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	// Creando el proceso huérfano y terminando el proceso padre
\end_layout

\begin_layout Plain Layout

	pid = fork();
\end_layout

\begin_layout Plain Layout

	if(pid < 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"No se puede crear proceso hijo
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return CANT_FORK;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if(pid > 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return OK;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Convirtiendo al huérfano en lider de la sesión
\end_layout

\begin_layout Plain Layout

	sid = setsid();
\end_layout

\begin_layout Plain Layout

	if(sid < 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"No se puede crear la sesión
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return SESSION_ERROR;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Cambiando al directorio / como directorio de trabajo
\end_layout

\begin_layout Plain Layout

	if( (chdir("/")) < 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"No se puede cambiar de directorio
\backslash
n");
\end_layout

\begin_layout Plain Layout

		return CHDIR_ERROR;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Cambiando Mascara 
\end_layout

\begin_layout Plain Layout

	umask(0);
\end_layout

\begin_layout Plain Layout

	// Cerrando descriptores estándard
\end_layout

\begin_layout Plain Layout

	close(STDIN_FILENO);
\end_layout

\begin_layout Plain Layout

	close(STDOUT_FILENO);
\end_layout

\begin_layout Plain Layout

	close(STDERR_FILENO);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	openlog("cold", LOG_PID, LOG_DAEMON);
\end_layout

\begin_layout Plain Layout

	syslog(LOG_INFO,"Cobros On Line Daemon
\backslash
n");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	argumento.lista_hilo = NULL;
\end_layout

\begin_layout Plain Layout

	i = 0;
\end_layout

\begin_layout Plain Layout

	while(1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		// MANEJO DE SEÑALES
\end_layout

\begin_layout Plain Layout

		sigset_t sigset;
\end_layout

\begin_layout Plain Layout

		struct sigaction action;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		sigemptyset(&sigset); /* Inicializa el conjunto de señales */
\end_layout

\begin_layout Plain Layout

		sigaddset(&sigset, SIGHUP); /* Reload Config file */
\end_layout

\begin_layout Plain Layout

		sigaddset(&sigset, SIGTERM); /* Parar el demonio */
\end_layout

\begin_layout Plain Layout

		sigprocmask(SIG_BLOCK, &sigset, NULL); /* Bloqueamos las señales */
\end_layout

\begin_layout Plain Layout

		sigpending(&sigset); /* Comprueba las señales pendientes */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if(!i)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			// SOCKET PARA ESCUCHAR CONEXIONES
\end_layout

\begin_layout Plain Layout

			socket_descriptor = socket(AF_INET, SOCK_STREAM, 0);
\end_layout

\begin_layout Plain Layout

			if( socket_descriptor == -1)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				syslog(LOG_ERR,"No se puede obtener un descriptor de socket
\backslash
n");
\end_layout

\begin_layout Plain Layout

				exit(SOCK_DESCRIPTOR_ERROR);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			argumento.socket_descriptor = socket_descriptor;
\end_layout

\begin_layout Plain Layout

			pthread_create(&manager,NULL, thread_manager, (void *) &argumento); 
\end_layout

\begin_layout Plain Layout

			i = 1;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if(sigismember(&sigset, SIGHUP)) {
\end_layout

\begin_layout Plain Layout

			syslog(LOG_INFO, "SIGHUP
\backslash
n");
\end_layout

\begin_layout Plain Layout

			sigemptyset(&action.sa_mask);
\end_layout

\begin_layout Plain Layout

			action.sa_handler = SIG_IGN;
\end_layout

\begin_layout Plain Layout

			sigaction(SIGHUP, &action, NULL);
\end_layout

\begin_layout Plain Layout

			/*
\end_layout

\begin_layout Plain Layout

				Reconfigurar el demonio
\end_layout

\begin_layout Plain Layout

			*/
\end_layout

\begin_layout Plain Layout

			socket_descriptor = argumento.socket_descriptor;
\end_layout

\begin_layout Plain Layout

			syslog(LOG_INFO,"Recargando fichero de configuración");
\end_layout

\begin_layout Plain Layout

			if( (ret = config_module(config_file, &argumento)) != 0)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				syslog(LOG_ERR,"Error con los parámetros de configuración config_module
 (%d)
\backslash
n",ret);
\end_layout

\begin_layout Plain Layout

				return CONFIG_ERROR;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			pthread_cancel(manager);
\end_layout

\begin_layout Plain Layout

			//syslog(LOG_INFO,"Socket cerrado tcp(%d)
\backslash
n",socket_descriptor);
\end_layout

\begin_layout Plain Layout

			/*
\end_layout

\begin_layout Plain Layout

			if( shutdown(socket_descriptor, 2) == -1)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				syslog(LOG_ERR,"No se puede cerrar el socket
\backslash
n");
\end_layout

\begin_layout Plain Layout

				return CANT_CLOSE_SOCKET;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			*/
\end_layout

\begin_layout Plain Layout

			close(socket_descriptor);
\end_layout

\begin_layout Plain Layout

			i= 0; //FLAG de administrador de hilos no corriendo
\end_layout

\begin_layout Plain Layout

			sigprocmask(SIG_UNBLOCK, &sigset, NULL);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(sigismember(&sigset, SIGTERM)) {
\end_layout

\begin_layout Plain Layout

			syslog(LOG_INFO, "SIGTERM
\backslash
n");
\end_layout

\begin_layout Plain Layout

			/* Ignora SIGTERM */
\end_layout

\begin_layout Plain Layout

			sigemptyset(&action.sa_mask);
\end_layout

\begin_layout Plain Layout

			action.sa_handler = SIG_IGN;
\end_layout

\begin_layout Plain Layout

			sigaction(SIGTERM, &action, NULL);
\end_layout

\begin_layout Plain Layout

			/*
\end_layout

\begin_layout Plain Layout

				Parar el demonio
\end_layout

\begin_layout Plain Layout

			*/
\end_layout

\begin_layout Plain Layout

			closelog();
\end_layout

\begin_layout Plain Layout

			close(argumento.socket_descriptor);
\end_layout

\begin_layout Plain Layout

			/* Desbloquea SIGHUP */
\end_layout

\begin_layout Plain Layout

			sigprocmask(SIG_UNBLOCK, &sigset, NULL);
\end_layout

\begin_layout Plain Layout

			syslog(LOG_INFO,"Parando el demonio
\backslash
n");
\end_layout

\begin_layout Plain Layout

			exit(OK);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		sleep(1);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
config_module.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char config_module(char * config_file, thread_arg * argumento)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	char * logpath;
\end_layout

\begin_layout Plain Layout

	char * logfile;
\end_layout

\begin_layout Plain Layout

	char * aclpath;
\end_layout

\begin_layout Plain Layout

	char * aclfile;
\end_layout

\begin_layout Plain Layout

	int ret;
\end_layout

\begin_layout Plain Layout

	int temp_fd;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// Invocación al config parser
\end_layout

\begin_layout Plain Layout

	if( (ret = config_parser(config_file, &(argumento->puerto), &(argumento->thread
s), &(argumento->timeout), &logpath, &logfile, &aclpath, &aclfile)) != OK
 )
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

                syslog(LOG_ERR,"Fichero de configuración inválido, config_parser
(%d)
\backslash
n",ret );
\end_layout

\begin_layout Plain Layout

                return ret;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Estableciendo el nombre completo del fichero acl
\end_layout

\begin_layout Plain Layout

	strcpy(argumento->acl,aclpath);
\end_layout

\begin_layout Plain Layout

	strcat(argumento->acl,aclfile);	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Estableciendo el nombre completo del fichero log
\end_layout

\begin_layout Plain Layout

	strcpy(argumento->log,logpath);
\end_layout

\begin_layout Plain Layout

	strcat(argumento->log,logfile);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Liberando la memoria reservada en config_parser
\end_layout

\begin_layout Plain Layout

	free(aclpath);
\end_layout

\begin_layout Plain Layout

	free(aclfile);
\end_layout

\begin_layout Plain Layout

	free(logpath);
\end_layout

\begin_layout Plain Layout

	free(logfile);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Hacer validaciones sobre los parámetros acl, y log
\end_layout

\begin_layout Plain Layout

	if( ( temp_fd  = open(argumento->acl, O_RDONLY) ) < 0 )
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

                syslog(LOG_ERR,"No existe el archivo %s o no se puede abrir
\backslash
n",argumento->acl);
\end_layout

\begin_layout Plain Layout

                return CANT_OPEN_ACL;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        close(temp_fd);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Just for debugging purposes 
\end_layout

\begin_layout Plain Layout

	//dbg_print_thread_arg(argumento);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void dbg_print_thread_arg(thread_arg * argumento)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "Printing ARG");
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "threads = %d
\backslash
n", argumento->threads);
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "puerto = %d
\backslash
n", argumento->puerto); 
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "timeout = %d
\backslash
n", argumento->timeout); 
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "acl = %s
\backslash
n", argumento->acl); 
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "log = %s
\backslash
n", argumento->log); 
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "thread_index = %d
\backslash
n", argumento->thread_index); 
\end_layout

\begin_layout Plain Layout

	syslog(LOG_DEBUG, "socket_descriptor = %d
\backslash
n", argumento->socket_descriptor); 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
config_parser.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int config_parser(char * config_file, int * puerto, int * threads, int *timeout,
 char ** logpath, char ** logfile, char ** aclpath, char ** aclfile)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	char *tokenPtr; //puntero para los tokens
\end_layout

\begin_layout Plain Layout

	char string[100]; //string donde se almacenan las lineas de configuracion
\end_layout

\begin_layout Plain Layout

	int i; //variable para el for
\end_layout

\begin_layout Plain Layout

	FILE *ficheroPtr;
\end_layout

\begin_layout Plain Layout

	//syslog(LOG_ERR,"config_file = %s
\backslash
n",config_file);
\end_layout

\begin_layout Plain Layout

	if(( ficheroPtr = fopen( config_file, "r")) == NULL)
\end_layout

\begin_layout Plain Layout

		return INVALID_CONFIG_FILE;
\end_layout

\begin_layout Plain Layout

	/* Comparacion de string con cada argumento de configuracion */
\end_layout

\begin_layout Plain Layout

	for(i=0; i<=6;i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

	/* Lectura de los argumentos de configuración */
\end_layout

\begin_layout Plain Layout

		fscanf( ficheroPtr, "%s", string);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		tokenPtr= strtok( string, "="); //se extrae el argumento hasta =    
\end_layout

\begin_layout Plain Layout

                if(strstr(tokenPtr,"port")) //si es port
\end_layout

\begin_layout Plain Layout

                {   
\end_layout

\begin_layout Plain Layout

                        tokenPtr = strtok(NULL," "); //se extrae la configuracio
n
\end_layout

\begin_layout Plain Layout

			sscanf(tokenPtr,"%d", puerto); //se almacena
\end_layout

\begin_layout Plain Layout

						
\end_layout

\begin_layout Plain Layout

//free(tokenPtr); //se libera la memoria
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strstr(tokenPtr,"threads")) //si es threads
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			tokenPtr = strtok(NULL," ");
\end_layout

\begin_layout Plain Layout

			sscanf(tokenPtr,"%d", threads); //se almacena
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strstr(tokenPtr,"timeout"))//si es timeout
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			tokenPtr = strtok(NULL," ");
\end_layout

\begin_layout Plain Layout

			sscanf(tokenPtr,"%d", timeout); //se almacena
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strstr(tokenPtr,"logpath"))//si es logpath
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			tokenPtr = strtok(NULL," ");
\end_layout

\begin_layout Plain Layout

			*logpath = (char *) malloc(sizeof(char)*strlen(tokenPtr));
\end_layout

\begin_layout Plain Layout

			strcpy(*logpath, tokenPtr);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strstr(tokenPtr,"logfile"))//si es logfile
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			tokenPtr = strtok(NULL," ");
\end_layout

\begin_layout Plain Layout

			*logfile = (char *) malloc(sizeof(char)*strlen(tokenPtr));
\end_layout

\begin_layout Plain Layout

			strcpy(*logfile, tokenPtr);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strstr(tokenPtr,"aclpath"))//si es aclpath
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			tokenPtr = strtok(NULL," ");
\end_layout

\begin_layout Plain Layout

			*aclpath = (char *) malloc(sizeof(char)*strlen(tokenPtr));
\end_layout

\begin_layout Plain Layout

			strcpy(*aclpath, tokenPtr);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strstr(tokenPtr,"aclfile"))//si es aclfile 
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			tokenPtr = strtok(NULL," ");
\end_layout

\begin_layout Plain Layout

			*aclfile = (char *) malloc(sizeof(char)*strlen(tokenPtr));
\end_layout

\begin_layout Plain Layout

			strcpy(*aclfile, tokenPtr);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	fclose(ficheroPtr);
\end_layout

\begin_layout Plain Layout

	return OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
coredaemon.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},language=C"
inline false
status collapsed

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <postgresql/libpq-fe.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void fin_hilo(thread_arg arg)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	close(arg.socket_descriptor);
\end_layout

\begin_layout Plain Layout

	pthread_mutex_lock(&lock);
\end_layout

\begin_layout Plain Layout

	--ready;
\end_layout

\begin_layout Plain Layout

	thread_del(&(arg.lista_hilo), arg.thread_index);
\end_layout

\begin_layout Plain Layout

	pthread_mutex_unlock(&lock);
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int recvtimeout(int socket, char *buffer, int len, int timeout)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	fd_set fds;
\end_layout

\begin_layout Plain Layout

	int n;
\end_layout

\begin_layout Plain Layout

	struct timeval tv;
\end_layout

\begin_layout Plain Layout

	FD_ZERO(&fds);
\end_layout

\begin_layout Plain Layout

	FD_SET(socket, &fds);
\end_layout

\begin_layout Plain Layout

	tv.tv_sec = timeout;
\end_layout

\begin_layout Plain Layout

	tv.tv_usec = 0;
\end_layout

\begin_layout Plain Layout

	n = select(socket+1, &fds, NULL, NULL, &tv);
\end_layout

\begin_layout Plain Layout

	if (n == 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return -2; // timeout!
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if (n == -1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return -1; // error
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	n = recv(socket, buffer, len, 0);
\end_layout

\begin_layout Plain Layout

	if( n > 0 )
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		buffer[n - 1] = '
\backslash
0';
\end_layout

\begin_layout Plain Layout

		limpiar_telnet(buffer);
\end_layout

\begin_layout Plain Layout

		--n;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return n;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void * coredaemon(void * argumento)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	time_t current_time;
\end_layout

\begin_layout Plain Layout

    char* c_time_string;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    /* Obtain current time as seconds elapsed since the Epoch.
 */
\end_layout

\begin_layout Plain Layout

    current_time = time(NULL);
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

    /* Convert to local time format.
 */
\end_layout

\begin_layout Plain Layout

    c_time_string = ctime(&current_time);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	thread_arg arg = *((thread_arg * ) argumento);
\end_layout

\begin_layout Plain Layout

	char print_buffer[STR_LEN];
\end_layout

\begin_layout Plain Layout

	char buffer[PKG_LEN];
\end_layout

\begin_layout Plain Layout

	char resp[PKG_LEN];
\end_layout

\begin_layout Plain Layout

	char temp[PKG_LEN];
\end_layout

\begin_layout Plain Layout

	int len,error;
\end_layout

\begin_layout Plain Layout

	char usuario[STR_LEN];
\end_layout

\begin_layout Plain Layout

	char clave[STR_LEN];
\end_layout

\begin_layout Plain Layout

	int log_fd;
\end_layout

\begin_layout Plain Layout

	SERVICIO serv;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	free(argumento);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if( (log_fd = open(arg.log, O_CREAT | O_WRONLY | O_APPEND, 0666)) < 0 )
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"No se puede abrir el fichero %s (%d)
\backslash
n",arg.log, log_fd);
\end_layout

\begin_layout Plain Layout

		exit(LOG_ERROR);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	writelog(log_fd,"Iniciando Autenticación
\backslash
n");
\end_layout

\begin_layout Plain Layout

	sprintf(resp,"Usuario: ");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if(send(arg.socket_descriptor, resp, strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if( ( len = recvtimeout(arg.socket_descriptor, buffer, 16384,arg.timeout)
 ) < 0 ) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd, "No se puede recibir: ");
\end_layout

\begin_layout Plain Layout

		if(len == -2)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, "Timeout
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, "Error de I/O
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if(len == 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd, "Conexión abortada
\backslash
n");
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	strcpy(usuario,buffer);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	sprintf(resp,"Clave: ");
\end_layout

\begin_layout Plain Layout

	if(send(arg.socket_descriptor, resp, strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if( ( len = recvtimeout(arg.socket_descriptor, buffer, 16384,arg.timeout)
 ) < 0 ) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd, "No se puede recibir
\backslash
n");
\end_layout

\begin_layout Plain Layout

		if(len == -2)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, "Timeout
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, "Error de I/O
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if(len == 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd, "Conexión abortada
\backslash
n");
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	strcpy(clave,buffer);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// AUTENTICACIÓN
\end_layout

\begin_layout Plain Layout

	if(authentication (arg.acl, usuario, hash(clave)) != 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,"Fallo de autenticación
\backslash
n");
\end_layout

\begin_layout Plain Layout

		sprintf(resp,"Credenciales inválidas
\backslash
n");
\end_layout

\begin_layout Plain Layout

		if(send(arg.socket_descriptor, resp, strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		sprintf(temp,"[Hilo %d] Cerrando la conexión
\backslash
n",arg.thread_index);
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	sprintf(temp,"Se autenticó exitosamente al usuario %s
\backslash
n",usuario);
\end_layout

\begin_layout Plain Layout

	writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	sprintf(resp,"Bienvenido al sistema de Cobros en Linea
\backslash
nEscriba help para ayuda
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

	if(send(arg.socket_descriptor, resp, strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	if( ( len = recvtimeout(arg.socket_descriptor, buffer, PKG_LEN,arg.timeout)
 ) < 0 ) 
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		writelog(log_fd, "No se puede recibir
\backslash
n");
\end_layout

\begin_layout Plain Layout

		if(len == -2)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, "Timeout
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, "Error de I/O
\backslash
n");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	while( len > 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		// Motor de Inferencia
\end_layout

\begin_layout Plain Layout

		if(strcmp(buffer,"close") == 0)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			sprintf(temp,"[%s::%s::close::Conexion terminada]
\backslash
n",c_time_string,usuario);
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

			fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strcmp(buffer,"help") == 0)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			//sprintf(temp,"IMPRIMIR LA AYUDA EN PANTALLA
\backslash
n");
\end_layout

\begin_layout Plain Layout

			sprintf(temp,"[%s::%s::help::Ayuda]
\backslash
n",c_time_string,usuario);
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

			if( db_module("help", serv,usuario,log_fd,resp) != 0)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

	               		writelog(log_fd,"Intentando mostrar la ayuda
\backslash
n");
\end_layout

\begin_layout Plain Layout

			}else{
\end_layout

\begin_layout Plain Layout

				if(send(arg.socket_descriptor, resp,strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

        			{
\end_layout

\begin_layout Plain Layout

                			writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

					fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

					return;
\end_layout

\begin_layout Plain Layout

        			}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strcmp(buffer,"lastrx") == 0)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			sprintf(temp,"Imprimir las 3 últimas transacciones
\backslash
n");
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

			if( db_module("lastrx", serv,usuario,log_fd,resp) != 0)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

	               		writelog(log_fd,"EXPLOTO BD Intentando mostrar las útlimas
 3 transacciones
\backslash
n");
\end_layout

\begin_layout Plain Layout

			}else{
\end_layout

\begin_layout Plain Layout

				if(send(arg.socket_descriptor, resp,strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

        			{
\end_layout

\begin_layout Plain Layout

                			writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

					fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

					return;
\end_layout

\begin_layout Plain Layout

        			}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strncmp(buffer,"col ",4) == 0)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			buffer[len-1] = '
\backslash
n';
\end_layout

\begin_layout Plain Layout

			if((error = col_parser(&serv,buffer+4,log_fd)) != 0)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				sprintf(temp,"ERROR: ");
\end_layout

\begin_layout Plain Layout

				writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

				switch (error)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

				case 30:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_COD_SERV
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Codigo de servicio invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 31:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_YEAR
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Año invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 32:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_DAY
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Dia invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 33:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_MONTH
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Mes invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 34:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_HOUR
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Hora invalida.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 35:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_MIN
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Minutos invalidos.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 36:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_SEC
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Segundos invalidos.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				if(send(arg.socket_descriptor, resp,strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

        			{
\end_layout

\begin_layout Plain Layout

                			writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

					fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

					return;
\end_layout

\begin_layout Plain Layout

        			}
\end_layout

\begin_layout Plain Layout

			}else{
\end_layout

\begin_layout Plain Layout

				//IMPRIMIR LOS RESULTADOS BLAH BLHA BLHA Y LOGGEAR
\end_layout

\begin_layout Plain Layout

				if(db_module("col",serv,usuario,log_fd,resp) != 0)
\end_layout

\begin_layout Plain Layout

	                		writelog(log_fd,"Database Error
\backslash
n");
\end_layout

\begin_layout Plain Layout

				if(send(arg.socket_descriptor, resp,strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

        			{
\end_layout

\begin_layout Plain Layout

                			writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

					fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

					return;
\end_layout

\begin_layout Plain Layout

        			}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(strncmp(buffer,"rev ",4) == 0)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			buffer[len-1] = '
\backslash
n';
\end_layout

\begin_layout Plain Layout

			if( (error = rev_parser(&serv,buffer+4)) != 0)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				sprintf(temp,"ERROR: ");
\end_layout

\begin_layout Plain Layout

				writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

				switch (error)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

				case 30:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_COD_SERV
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Codigo de servicio invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 31:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_YEAR
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Año invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 32:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_DAY
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Dia invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 33:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_MONTH
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Mes invalido.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 34:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_HOUR
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Hora invalida.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 35:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_MIN
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Minutos invalidos.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				case 36:
\end_layout

\begin_layout Plain Layout

					sprintf(temp,"INVALID_SEC
\backslash
n");
\end_layout

\begin_layout Plain Layout

					writelog(log_fd, temp);
\end_layout

\begin_layout Plain Layout

					sprintf(resp,"ERROR: Segundos invalidos.
 Verifique y reintente
\backslash
n$ ");
\end_layout

\begin_layout Plain Layout

					break;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				if(send(arg.socket_descriptor, resp,strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

        			{
\end_layout

\begin_layout Plain Layout

                			writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

					fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

					return;
\end_layout

\begin_layout Plain Layout

        			}
\end_layout

\begin_layout Plain Layout

			}else{
\end_layout

\begin_layout Plain Layout

				//IMPRIMIR LOS RESULTADOS BLAH BLHA BLHA Y LOGGEAR
\end_layout

\begin_layout Plain Layout

				if(db_module("rev",serv,usuario,log_fd,resp) != 0)
\end_layout

\begin_layout Plain Layout

	                		writelog(log_fd,"EXPLOTO BD
\backslash
n");
\end_layout

\begin_layout Plain Layout

				if(send(arg.socket_descriptor, resp,strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

        			{
\end_layout

\begin_layout Plain Layout

                			writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

					fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

					return;
\end_layout

\begin_layout Plain Layout

        			}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		sprintf(resp,"$ ");
\end_layout

\begin_layout Plain Layout

		if(send(arg.socket_descriptor, resp,strlen(resp),0) == -1)
\end_layout

\begin_layout Plain Layout

        	{
\end_layout

\begin_layout Plain Layout

                	writelog(log_fd,"No se puede enviar
\backslash
n");
\end_layout

\begin_layout Plain Layout

			fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

        	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if( ( len = recvtimeout(arg.socket_descriptor, buffer, PKG_LEN,arg.timeout)
 ) < 0 )
\end_layout

\begin_layout Plain Layout

        	{
\end_layout

\begin_layout Plain Layout

                	writelog(log_fd, "no se puede recibir
\backslash
n");
\end_layout

\begin_layout Plain Layout

			if(len == -2)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				writelog(log_fd, "Timeout
\backslash
n");
\end_layout

\begin_layout Plain Layout

			}else{
\end_layout

\begin_layout Plain Layout

				writelog(log_fd, "Error de I/O
\backslash
n");
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

        	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	sprintf(print_buffer,"Hilo %d cerrando la conexión
\backslash
n", arg.thread_index);
\end_layout

\begin_layout Plain Layout

	writelog(log_fd,print_buffer);
\end_layout

\begin_layout Plain Layout

	close(log_fd);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	fin_hilo(arg);
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void limpiar_telnet(char * cadena)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int i = 0;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while(cadena[i] != '
\backslash
0')
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if(cadena[i] == '
\backslash
015')
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			cadena[i] = '
\backslash
0';
\end_layout

\begin_layout Plain Layout

			break;
\end_layout

\begin_layout Plain Layout

		} 
\end_layout

\begin_layout Plain Layout

		i++;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
db_coldaemon.sql
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=SQL,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

DROP TABLE IF EXISTS pagadas, pendientes, transacciones;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE TABLE pagadas(cod_serv INTEGER, tipo INTEGER, compr BIGINT, monto
 BIGINT, dig_verif INTEGER, prefijo INTEGER, numero INTEGER, medidor BIGINT,
 abonado BIGINT, transaccion INTEGER, fecha_hora BIGINT,  usuario TEXT,
 vencimiento BIGINT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE TABLE pendientes(cod_serv INTEGER,tipo INTEGER,compr BIGINT,monto
 BIGINT,dig_verif INTEGER,prefijo INTEGER,numero INTEGER ,medidor BIGINT,
 abonado BIGINT, id INTEGER,vencimiento BIGINT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CREATE TABLE transacciones(operacion TEXT, cod_serv INTEGER, fecha_hora
 TEXT, usuario TEXT, mensaje TEXT,tipo INTEGER, compr BIGINT, monto BIGINT,
 dig_verif INTEGER, prefijo INTEGER, numero INTEGER, medidor BIGINT, abonado
 BIGINT, transaccion INTEGER);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

INSERT INTO pendientes VALUES (001,001,12345678912,000000100000,7,0,0,0,0,1,2013
1212235959);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

INSERT INTO pendientes VALUES (002,001,0,000000100000,0,0644,9876543,0,0,2,20131
212235959);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

INSERT INTO pendientes VALUES (003,0,0,000000100000,0,0,0,987654321012345,0,3,20
131212235959);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

INSERT INTO pendientes VALUES (004,0,0,000000100000,0,0644,987654,0,0,4,20131212
235959);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

INSERT INTO pendientes VALUES (005,0,0,000000100000,0,0,0,0,987654321,5,20131212
235959);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
db_module.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language={C++},showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void
\end_layout

\begin_layout Plain Layout

exit_nicely(PGconn *conn)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    PQfinish(conn);
\end_layout

\begin_layout Plain Layout

    return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int existe_factura(const char * cod_serv, const char * compr,const char
 * medidor, const char * prefijo, const char * numero, const char * abonado,cons
t char * monto, const char * vencimiento, PGconn * conn, PGresult * res,int
 log_fd,char * resp){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	const char *parametros[8];
\end_layout

\begin_layout Plain Layout

	parametros[0] = compr;
\end_layout

\begin_layout Plain Layout

	parametros[1] = medidor;
\end_layout

\begin_layout Plain Layout

	parametros[2] = abonado;
\end_layout

\begin_layout Plain Layout

	parametros[3] = prefijo;
\end_layout

\begin_layout Plain Layout

	parametros[4] = numero;
\end_layout

\begin_layout Plain Layout

	parametros[5] = monto;
\end_layout

\begin_layout Plain Layout

	parametros[6] = vencimiento;
\end_layout

\begin_layout Plain Layout

	parametros[7] = cod_serv;
\end_layout

\begin_layout Plain Layout

	int entero = 0;
\end_layout

\begin_layout Plain Layout

	char temp[512];
\end_layout

\begin_layout Plain Layout

	res = PQexecParams(conn,"SELECT * FROM pendientes WHERE (compr=$1 OR medidor=$2
 OR abonado=$3 OR (numero=$4 AND prefijo=$5)) AND (monto=$6 AND vencimiento>=$7
 AND cod_serv=$8);",
\end_layout

\begin_layout Plain Layout

						8,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						parametros,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (PQntuples(res) == 0)
\end_layout

\begin_layout Plain Layout

    	{
\end_layout

\begin_layout Plain Layout

		sprintf(resp,"Factura invalida
\backslash
n");
\end_layout

\begin_layout Plain Layout

    		sprintf(temp,"Factura inválida
\backslash
n");
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

       		entero = 1;
\end_layout

\begin_layout Plain Layout

    	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

    	PQclear(res);
\end_layout

\begin_layout Plain Layout

	return entero;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int existe_trx(const char * transaccion, PGconn * conn, PGresult * res,
 int log_fd, char * resp){
\end_layout

\begin_layout Plain Layout

	const char *parametros[1];
\end_layout

\begin_layout Plain Layout

	parametros[0] = transaccion;
\end_layout

\begin_layout Plain Layout

	int entero = 0;
\end_layout

\begin_layout Plain Layout

	char temp[512];
\end_layout

\begin_layout Plain Layout

	res = PQexecParams(conn, "SELECT * FROM pagadas WHERE transaccion=$1",
\end_layout

\begin_layout Plain Layout

						1,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						parametros,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

	if (PQntuples(res) == 0)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		sprintf(resp,"No existe transaccion a reversar
\backslash
n");
\end_layout

\begin_layout Plain Layout

		sprintf(temp,"No existe transaccion a reversar
\backslash
n");
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

		entero = 1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	PQclear(res);
\end_layout

\begin_layout Plain Layout

	return entero;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int db_module(char * operacion, SERVICIO serv, char * usuario, int log_fd,
 char * resp)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	time_t current_time;
\end_layout

\begin_layout Plain Layout

   	char* c_time_string;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

	//Se obtiene el tiempo en segundos 
\end_layout

\begin_layout Plain Layout

	current_time = time(NULL);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Se convierte al formato de hora local
\end_layout

\begin_layout Plain Layout

	c_time_string = ctime(&current_time);
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

	char temp[512] = {0};
\end_layout

\begin_layout Plain Layout

	const char 	*conninfo;  
\end_layout

\begin_layout Plain Layout

	PGconn     	*conn;
\end_layout

\begin_layout Plain Layout

	PGresult   	*res;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  	const char *paramValues[15];
\end_layout

\begin_layout Plain Layout

  	const char *paramValues2[14]; //utilizado para comandos de eliminacion
\end_layout

\begin_layout Plain Layout

	const char *paramRev[14];
\end_layout

\begin_layout Plain Layout

	int         paramLengths[14];
\end_layout

\begin_layout Plain Layout

	int         paramFormats[14];
\end_layout

\begin_layout Plain Layout

	int		t,f,tuples;              
\end_layout

\begin_layout Plain Layout

	char aux_monto[512];
\end_layout

\begin_layout Plain Layout

	char aux_nummed[512];
\end_layout

\begin_layout Plain Layout

	char aux_numtran[512];
\end_layout

\begin_layout Plain Layout

	char aux_venc[512];
\end_layout

\begin_layout Plain Layout

	char aux_verificador[2];
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	conninfo = "dbname = coldaemon";
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	paramValues[0] = serv.codser;
\end_layout

\begin_layout Plain Layout

	paramValues[1] = serv.tipofact;
\end_layout

\begin_layout Plain Layout

	paramValues[2] = serv.comprobante;
\end_layout

\begin_layout Plain Layout

	sprintf(aux_monto,"%lu",serv.monto);
\end_layout

\begin_layout Plain Layout

	paramValues[3] = aux_monto;
\end_layout

\begin_layout Plain Layout

	sprintf(temp,"Monto = %s
\backslash
n",paramValues[3]);
\end_layout

\begin_layout Plain Layout

	sprintf(aux_verificador,"%d",serv.verificador);
\end_layout

\begin_layout Plain Layout

	paramValues[4] = aux_verificador;
\end_layout

\begin_layout Plain Layout

	paramValues[5] = serv.prefijo;
\end_layout

\begin_layout Plain Layout

	paramValues[6] = serv.numero;
\end_layout

\begin_layout Plain Layout

	paramValues[7] = serv.nummed;
\end_layout

\begin_layout Plain Layout

	paramValues[8] = serv.abonado;
\end_layout

\begin_layout Plain Layout

	sprintf(aux_numtran,"%d",serv.numtran);
\end_layout

\begin_layout Plain Layout

	paramValues[9] = aux_numtran;
\end_layout

\begin_layout Plain Layout

	paramValues[10] = serv.fechahora;
\end_layout

\begin_layout Plain Layout

	paramValues[11] = usuario;
\end_layout

\begin_layout Plain Layout

	paramValues[12] = "20131212235959";
\end_layout

\begin_layout Plain Layout

	paramValues[13] = operacion;
\end_layout

\begin_layout Plain Layout

	paramValues[14] = serv.mensaje;
\end_layout

\begin_layout Plain Layout

	/*strcpy(aux_venc,serv.vencimiento);
\end_layout

\begin_layout Plain Layout

	strcat(aux_venc,"235959");
\end_layout

\begin_layout Plain Layout

	paramValues[12] = aux_venc;*/
\end_layout

\begin_layout Plain Layout

	paramRev[0]=operacion;
\end_layout

\begin_layout Plain Layout

	paramRev[1]=serv.codser;
\end_layout

\begin_layout Plain Layout

	paramRev[2]=serv.fechahora;
\end_layout

\begin_layout Plain Layout

	paramRev[3]=usuario; 
\end_layout

\begin_layout Plain Layout

	paramRev[4]=serv.mensaje;
\end_layout

\begin_layout Plain Layout

	paramRev[5]=serv.tipofact;
\end_layout

\begin_layout Plain Layout

	paramRev[6]=serv.comprobante;
\end_layout

\begin_layout Plain Layout

	paramRev[7]=aux_monto;
\end_layout

\begin_layout Plain Layout

	paramRev[8]=aux_verificador;
\end_layout

\begin_layout Plain Layout

	paramRev[9]=serv.prefijo;
\end_layout

\begin_layout Plain Layout

	paramRev[10]=serv.numero;
\end_layout

\begin_layout Plain Layout

	paramRev[11]=serv.nummed;
\end_layout

\begin_layout Plain Layout

	paramRev[12]=serv.abonado;
\end_layout

\begin_layout Plain Layout

	paramRev[13]=aux_numtran;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// Se realiza la conexión a la base de datos
\end_layout

\begin_layout Plain Layout

    conn = PQconnectdb(conninfo);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// Se chequea si la conexión backend ha sido establecida
\end_layout

\begin_layout Plain Layout

    if (PQstatus(conn) != CONNECTION_OK)
\end_layout

\begin_layout Plain Layout

    {
\end_layout

\begin_layout Plain Layout

        sprintf(temp, "Connection to database failed: %s",
\end_layout

\begin_layout Plain Layout

        PQerrorMessage(conn));
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

        exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

	//INICIO DE OPERACIONES EN LA BASE DE DATOS
\end_layout

\begin_layout Plain Layout

	if(strcmp(operacion, "col") == 0){
\end_layout

\begin_layout Plain Layout

		sprintf(temp,"[%s::%s::%s::Peticion de cobro]
\backslash
n",c_time_string,usuario,operacion);
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

		/*
\end_layout

\begin_layout Plain Layout

		*	se envia serv.fecha hora a existe_factura y no serv.vencimiento
\end_layout

\begin_layout Plain Layout

		*	se cambia paramValues[10] por paramValues[12]
\end_layout

\begin_layout Plain Layout

		*/
\end_layout

\begin_layout Plain Layout

		if(existe_factura(paramValues[0],paramValues[2],paramValues[7],paramValues[5],
paramValues[6],paramValues[8],paramValues[3],paramValues[10],conn,res,log_fd,res
p) == 0){
\end_layout

\begin_layout Plain Layout

			//insertar registro en la tabla de pagadas
\end_layout

\begin_layout Plain Layout

			res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

                       "INSERT INTO pagadas VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$
10,$11,$12,$13);",
\end_layout

\begin_layout Plain Layout

                       13,       // 13 parametros
\end_layout

\begin_layout Plain Layout

                       NULL,    // let the backend deduce param type
\end_layout

\begin_layout Plain Layout

                       paramValues,
\end_layout

\begin_layout Plain Layout

                       NULL,    // don't need param lengths since text
\end_layout

\begin_layout Plain Layout

                       NULL,    // default to all text params
\end_layout

\begin_layout Plain Layout

                       0);      // ask for non binary results
\end_layout

\begin_layout Plain Layout

            if (PQresultStatus(res) != PGRES_COMMAND_OK)
\end_layout

\begin_layout Plain Layout

    		{
\end_layout

\begin_layout Plain Layout

			//SE GENERA EL MENSAJE DE RETORNO
\end_layout

\begin_layout Plain Layout

			sprintf(resp,"%s%s%s001Fallo el cobro
\backslash
n",				serv.codser,aux_numtran,serv.fechahora);
\end_layout

\begin_layout Plain Layout

        		sprintf(temp,"insert command failed: %s", PQerrorMessage(conn));
\end_layout

\begin_layout Plain Layout

			writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

        		PQclear(res);
\end_layout

\begin_layout Plain Layout

        		exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    		}     
\end_layout

\begin_layout Plain Layout

    		
\end_layout

\begin_layout Plain Layout

			PQclear(res);
\end_layout

\begin_layout Plain Layout

			//eliminar registro de la tabla pendientes
\end_layout

\begin_layout Plain Layout

			//asignar valores a paramValues (si! hace falta)
\end_layout

\begin_layout Plain Layout

			if (strcmp(serv.codser,"001") == 0)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				//eliminar aguas
\end_layout

\begin_layout Plain Layout

				paramValues2[0] = serv.comprobante;
\end_layout

\begin_layout Plain Layout

				res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

						"DELETE FROM pendientes WHERE compr=$1;",
\end_layout

\begin_layout Plain Layout

						1,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						paramValues2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

			}else if(strcmp(serv.codser,"002") == 0){
\end_layout

\begin_layout Plain Layout

				//eliminar fijo
\end_layout

\begin_layout Plain Layout

				paramValues2[0] = serv.prefijo;
\end_layout

\begin_layout Plain Layout

				paramValues2[1] = serv.numero;
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

						"DELETE FROM pendientes WHERE numero=$2 AND prefijo=$1;",
\end_layout

\begin_layout Plain Layout

						2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						paramValues2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

			}else if(strcmp(serv.codser,"003") == 0){
\end_layout

\begin_layout Plain Layout

				//eliminar electricidad
\end_layout

\begin_layout Plain Layout

				paramValues2[0] = serv.nummed;
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

						"DELETE FROM pendientes WHERE medidor=$1;",
\end_layout

\begin_layout Plain Layout

						1,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						paramValues2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

			}else if(strcmp(serv.codser,"004") == 0){
\end_layout

\begin_layout Plain Layout

				//eliminar movil
\end_layout

\begin_layout Plain Layout

				paramValues2[0] = serv.prefijo;
\end_layout

\begin_layout Plain Layout

				paramValues2[1] = serv.numero;
\end_layout

\begin_layout Plain Layout

				res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

						"DELETE FROM pendientes WHERE (prefijo=$1 AND numero=$2);",
\end_layout

\begin_layout Plain Layout

						2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						paramValues2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

			}else if(strcmp(serv.codser,"005") == 0){
\end_layout

\begin_layout Plain Layout

				//eliminar cable
\end_layout

\begin_layout Plain Layout

				paramValues2[0] = serv.abonado;
\end_layout

\begin_layout Plain Layout

				res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

						"DELETE FROM pendientes WHERE abonado=$1;",
\end_layout

\begin_layout Plain Layout

						1,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						paramValues2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if (PQresultStatus(res) != PGRES_COMMAND_OK)
\end_layout

\begin_layout Plain Layout

    		{
\end_layout

\begin_layout Plain Layout

			//SE GENERA EL MENSAJE DE RETORNO
\end_layout

\begin_layout Plain Layout

			sprintf(resp,"%s%s%s001Fallo el cobro
\backslash
n",serv.codser,aux_numtran,serv.fechahora);
\end_layout

\begin_layout Plain Layout

        		sprintf(temp,"delete command failed: %s", PQerrorMessage(conn));
\end_layout

\begin_layout Plain Layout

				writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

        		PQclear(res);
\end_layout

\begin_layout Plain Layout

        		exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    		}
\end_layout

\begin_layout Plain Layout

    		
\end_layout

\begin_layout Plain Layout

			PQclear(res);
\end_layout

\begin_layout Plain Layout

			//agregar a transacciones
\end_layout

\begin_layout Plain Layout

    		res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

        	"INSERT INTO transacciones VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$
12,$13,$14);",
\end_layout

\begin_layout Plain Layout

           	14,       // 13 parametros
\end_layout

\begin_layout Plain Layout

            NULL,    // let the backend deduce param type
\end_layout

\begin_layout Plain Layout

            paramRev,
\end_layout

\begin_layout Plain Layout

            NULL,    // don't need param lengths since text
\end_layout

\begin_layout Plain Layout

            NULL,    // default to all text params
\end_layout

\begin_layout Plain Layout

            0);      // ask for non binary results
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			if (PQresultStatus(res) != PGRES_COMMAND_OK)
\end_layout

\begin_layout Plain Layout

    		{
\end_layout

\begin_layout Plain Layout

			//SE GENERA EL MENSAJE DE RETORNO
\end_layout

\begin_layout Plain Layout

			sprintf(resp,"%s%s%s001Fallo el cobro
\backslash
n",serv.codser,aux_numtran,serv.fechahora);
\end_layout

\begin_layout Plain Layout

        		sprintf(temp,"fallo de envio a transaccion: %s", PQerrorMessage(conn))
;
\end_layout

\begin_layout Plain Layout

				writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

        		PQclear(res);
\end_layout

\begin_layout Plain Layout

        		exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    		}
\end_layout

\begin_layout Plain Layout

		sprintf(resp,"%s%s%s000Cobro Exitoso
\backslash
n",serv.codser,aux_numtran,serv.fechahora);
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,resp);
\end_layout

\begin_layout Plain Layout

    		PQclear(res);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}else if(strcmp(operacion, "rev") == 0){
\end_layout

\begin_layout Plain Layout

		sprintf(temp,"[%s::%s::%s::Peticion de reversa]
\backslash
n", 					c_time_string,usuario,operacion);
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

		if(existe_trx(paramValues[9],conn,res,log_fd,resp) == 0){
\end_layout

\begin_layout Plain Layout

			sprintf(temp,"Existe la transaccion
\backslash
nMoviendo a pendientes
\backslash
n");
\end_layout

\begin_layout Plain Layout

			writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			//mover a pendientes
\end_layout

\begin_layout Plain Layout

			res = PQexec(conn,"INSERT INTO pendientes 		(cod_serv,tipo,compr,monto,vencim
iento,dig_verif,prefijo,numero,medidor,abonado) SELECT cod_serv,tipo,compr,monto
,vencimiento,dig_verif,prefijo,numero,medidor,abonado	FROM pagadas;");
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			if (PQresultStatus(res) != PGRES_COMMAND_OK)
\end_layout

\begin_layout Plain Layout

    			{
\end_layout

\begin_layout Plain Layout

        		sprintf(temp,"moving command failed: %s", PQerrorMessage(conn));
\end_layout

\begin_layout Plain Layout

			writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

        		PQclear(res);
\end_layout

\begin_layout Plain Layout

        		exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    			}
\end_layout

\begin_layout Plain Layout

    		
\end_layout

\begin_layout Plain Layout

			//borrar de pagadas
\end_layout

\begin_layout Plain Layout

			sprintf(temp,"borrando de pagadas
\backslash
n");
\end_layout

\begin_layout Plain Layout

			writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

			paramValues2[0] = aux_numtran;
\end_layout

\begin_layout Plain Layout

			res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

                       "DELETE FROM pagadas WHERE transaccion=$1;",
\end_layout

\begin_layout Plain Layout

                       1,       // 1 parametro
\end_layout

\begin_layout Plain Layout

                       NULL,    // let the backend deduce param type
\end_layout

\begin_layout Plain Layout

                       paramValues2,
\end_layout

\begin_layout Plain Layout

                       NULL,    // don't need param lengths since text
\end_layout

\begin_layout Plain Layout

                       NULL,    // default to all text params
\end_layout

\begin_layout Plain Layout

                       0);      // ask for non binary results
\end_layout

\begin_layout Plain Layout

                       
\end_layout

\begin_layout Plain Layout

            		if (PQresultStatus(res) != PGRES_COMMAND_OK)
\end_layout

\begin_layout Plain Layout

    			{
\end_layout

\begin_layout Plain Layout

				sprintf(temp,"delete rev command failed: %s",PQerrorMessage(conn));
\end_layout

\begin_layout Plain Layout

				writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

				PQclear(res);
\end_layout

\begin_layout Plain Layout

				exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    			}
\end_layout

\begin_layout Plain Layout

    		
\end_layout

\begin_layout Plain Layout

    		//agregar a transacciones
\end_layout

\begin_layout Plain Layout

    		res = PQexecParams(conn,
\end_layout

\begin_layout Plain Layout

        	"INSERT INTO transacciones VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$
12,$13,$14);",
\end_layout

\begin_layout Plain Layout

           	14,       // 13 parametros
\end_layout

\begin_layout Plain Layout

            NULL,    // let the backend deduce param type
\end_layout

\begin_layout Plain Layout

            paramRev,
\end_layout

\begin_layout Plain Layout

            NULL,    // don't need param lengths since text
\end_layout

\begin_layout Plain Layout

            NULL,    // default to all text params
\end_layout

\begin_layout Plain Layout

            0);      // ask for non binary results
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

		if (PQresultStatus(res) != PGRES_COMMAND_OK)
\end_layout

\begin_layout Plain Layout

    		{
\end_layout

\begin_layout Plain Layout

        		sprintf(temp,"fallo de envio a transaccion: %s", PQerrorMessage(conn))
;
\end_layout

\begin_layout Plain Layout

				writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

        		PQclear(res);
\end_layout

\begin_layout Plain Layout

        		exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

    		PQclear(res);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}else if(strcmp(operacion, "lastrx") == 0){
\end_layout

\begin_layout Plain Layout

		sprintf(temp,"[%s::%s::%s::Peticion de listado]
\backslash
n",c_time_string,usuario,operacion);
\end_layout

\begin_layout Plain Layout

		writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

		paramValues2[0] = usuario;
\end_layout

\begin_layout Plain Layout

		int retorno = 0;
\end_layout

\begin_layout Plain Layout

		res = PQexecParams(conn, "SELECT * FROM transacciones WHERE usuario=$1;",
\end_layout

\begin_layout Plain Layout

						1,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						paramValues2,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						NULL,
\end_layout

\begin_layout Plain Layout

						0);
\end_layout

\begin_layout Plain Layout

		if (PQntuples(res) == 0)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			sprintf(temp,"No hay transacciones recientes
\backslash
n");
\end_layout

\begin_layout Plain Layout

			writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

			sprintf(resp,"No hay transacciones recientes
\backslash
n");
\end_layout

\begin_layout Plain Layout

			retorno = 1;
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

			resp[0] = '
\backslash
0';
\end_layout

\begin_layout Plain Layout

			tuples = PQntuples(res) - 3;
\end_layout

\begin_layout Plain Layout

			if (PQntuples(res) < 3)
\end_layout

\begin_layout Plain Layout

				tuples = 0;
\end_layout

\begin_layout Plain Layout

			for(t = tuples; t < PQntuples(res); t++)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				for (f = 0; f < PQnfields(res); f++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

				    //concatenar resultados de PQgetvalue
\end_layout

\begin_layout Plain Layout

				    sprintf(temp,"%s ", PQgetvalue(res, t, f));
\end_layout

\begin_layout Plain Layout

					strcat(resp,temp);
\end_layout

\begin_layout Plain Layout

					writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				sprintf(temp,"
\backslash
n");
\end_layout

\begin_layout Plain Layout

				strcat(resp,temp);
\end_layout

\begin_layout Plain Layout

				writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		PQclear(res);
\end_layout

\begin_layout Plain Layout

		//agregar a transacciones
\end_layout

\begin_layout Plain Layout

		/*
\end_layout

\begin_layout Plain Layout

		*	Se podria guardar la fecha/hora del sistema
\end_layout

\begin_layout Plain Layout

		*/
\end_layout

\begin_layout Plain Layout

		paramRev[2] = c_time_string;
\end_layout

\begin_layout Plain Layout

    		res = PQexecParams(conn,"INSERT INTO transacciones VALUES ($1,$2,$3,$4,'0'
,0,0,0,0,0,0,0,0,0);",
\end_layout

\begin_layout Plain Layout

		4,       // 14 parametros
\end_layout

\begin_layout Plain Layout

            NULL,    // let the backend deduce param type
\end_layout

\begin_layout Plain Layout

            paramRev,
\end_layout

\begin_layout Plain Layout

            NULL,    // don't need param lengths since text
\end_layout

\begin_layout Plain Layout

            NULL,    // default to all text params
\end_layout

\begin_layout Plain Layout

            0);      // ask for non binary results
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			if (PQresultStatus(res) != PGRES_COMMAND_OK)
\end_layout

\begin_layout Plain Layout

    		{
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

        		sprintf(temp,"fallo de envio a transaccion: %s", PQerrorMessage(conn))
;
\end_layout

\begin_layout Plain Layout

				writelog(log_fd,temp);
\end_layout

\begin_layout Plain Layout

        		PQclear(res);
\end_layout

\begin_layout Plain Layout

        		exit_nicely(conn);
\end_layout

\begin_layout Plain Layout

    		}
\end_layout

\begin_layout Plain Layout

    		PQclear(res);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	}else if(strcmp(operacion, "help") == 0){
\end_layout

\begin_layout Plain Layout

		sprintf(resp,"Comandos:
\backslash
n- col <parametros> Realiza un cobro con la transaccion indicada por parametros.
\backslash
n- rev <parametros> Realiza una reversa de la transaccion indicada por paramtros.
\backslash
n- lastrx Consulta las ultimas transacciones hechas por el usuario.
\backslash
n- close Cierra la conexion con el servidor
\backslash
n");
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	//Se cierra la conexión a la base de datos
\end_layout

\begin_layout Plain Layout

    PQfinish(conn);
\end_layout

\begin_layout Plain Layout

	return OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
thread_manager.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void * thread_manager(void * argumento)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	thread_arg arg = *((thread_arg *) argumento);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	char * log = arg.log;
\end_layout

\begin_layout Plain Layout

	int puerto = arg.puerto;
\end_layout

\begin_layout Plain Layout

	int threads = arg.threads;
\end_layout

\begin_layout Plain Layout

	int log_fd;
\end_layout

\begin_layout Plain Layout

	char printBuffer[STR_LEN];
\end_layout

\begin_layout Plain Layout

	//SOCKET
\end_layout

\begin_layout Plain Layout

	struct sockaddr_in pin;
\end_layout

\begin_layout Plain Layout

	struct sockaddr_in sin;
\end_layout

\begin_layout Plain Layout

	int temp_sock_descriptor;
\end_layout

\begin_layout Plain Layout

	int address_size;
\end_layout

\begin_layout Plain Layout

	char buf[PKG_LEN];
\end_layout

\begin_layout Plain Layout

	int create_thread_value;
\end_layout

\begin_layout Plain Layout

	int ret;
\end_layout

\begin_layout Plain Layout

	thread_arg * arg_for_thread = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if( (log_fd = open(log, O_CREAT | O_WRONLY | O_APPEND, 0666)) < 0 )
\end_layout

\begin_layout Plain Layout

	{ 
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"No se puede abrir el fichero %s (%d)
\backslash
n",log, log_fd);
\end_layout

\begin_layout Plain Layout

		exit(LOG_ERROR);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	strcpy(printBuffer,"[cold] Cobros On-Line Daemon
\backslash
n");
\end_layout

\begin_layout Plain Layout

	writelog(log_fd,printBuffer);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	bzero(&sin, sizeof(sin));
\end_layout

\begin_layout Plain Layout

	sin.sin_family = AF_INET;
\end_layout

\begin_layout Plain Layout

	sin.sin_addr.s_addr = INADDR_ANY;
\end_layout

\begin_layout Plain Layout

	sin.sin_port = htons(puerto);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if( (ret = bind(arg.socket_descriptor, (struct sockaddr *)&(sin), sizeof(sin)))
 == -1 )
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"No se puede usar el puerto %d
\backslash
n",puerto);
\end_layout

\begin_layout Plain Layout

		exit(BINDING_ERROR);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if( listen(arg.socket_descriptor, threads) == -1 )
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		syslog(LOG_ERR,"No se puede escuchar en el puerto %d
\backslash
n",puerto);
\end_layout

\begin_layout Plain Layout

		exit(LISTENNING_ERROR);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	sprintf(printBuffer,"Esperando conexiones en el puerto %d
\backslash
n",puerto);
\end_layout

\begin_layout Plain Layout

	writelog(log_fd,printBuffer);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while(1)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		temp_sock_descriptor = accept(arg.socket_descriptor, (struct sockaddr *)&
 pin, &address_size);
\end_layout

\begin_layout Plain Layout

		if( temp_sock_descriptor == -1 )
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			syslog(LOG_ERR,"No se puede aceptar la conexión
\backslash
n");
\end_layout

\begin_layout Plain Layout

			exit(ACCEPT_CONNECTION_ERROR);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		//strcpy(printBuffer,"Conexión Entrante
\backslash
n");
\end_layout

\begin_layout Plain Layout

		//writelog(log_fd, printBuffer);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// Asignar argumentos y ejecutar hilos
\end_layout

\begin_layout Plain Layout

		if( ready <  arg.threads )
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			ready++;
\end_layout

\begin_layout Plain Layout

			//syslog(LOG_DEBUG,"Ejecutando el hilo %d
\backslash
n",ready);
\end_layout

\begin_layout Plain Layout

			arg_for_thread = (thread_arg *)malloc(sizeof(thread_arg));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			*arg_for_thread = arg;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			arg_for_thread->thread_index = ready;
\end_layout

\begin_layout Plain Layout

			arg_for_thread->socket_descriptor = temp_sock_descriptor;
\end_layout

\begin_layout Plain Layout

			arg_for_thread->socket = pin;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			thread_add(&(arg_for_thread->lista_hilo), ready);
\end_layout

\begin_layout Plain Layout

			create_thread_value = pthread_create(thread_get(arg_for_thread->lista_hilo,re
ady),NULL, coredaemon, (void *) arg_for_thread); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			//syslog(LOG_DEBUG,"create_thread_value = %d
\backslash
n",create_thread_value);
\end_layout

\begin_layout Plain Layout

			//syslog(LOG_DEBUG,"Usando Hilo %d
\backslash
n",ready);
\end_layout

\begin_layout Plain Layout

		}else{
\end_layout

\begin_layout Plain Layout

			// Rechazar la conexión
\end_layout

\begin_layout Plain Layout

			sprintf(printBuffer,"El servidor no acepta más conexiones en este momento
\backslash
nPor favor aguarde un momento y reintente conectarse nuevamente
\backslash
n");
\end_layout

\begin_layout Plain Layout

			if(send(temp_sock_descriptor, printBuffer, strlen(printBuffer), 0) ==
 -1)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				syslog(LOG_ERR,"Error al informar que ya no se aceptan más conexiónes
\backslash
n");
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			strcpy(printBuffer, "No hay hilos disponibles
\backslash
n");
\end_layout

\begin_layout Plain Layout

			writelog(log_fd, printBuffer);
\end_layout

\begin_layout Plain Layout

			close(temp_sock_descriptor);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
transa_parser.c
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize\ttfamily},breaklines=true,language=C,showstringspaces=false"
inline false
status collapsed

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char col_parser (SERVICIO *servicio, char * patron,int log_fd)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int contcar = 0; //contador de caracteres
\end_layout

\begin_layout Plain Layout

	char string[58] = {0}; //rubro
\end_layout

\begin_layout Plain Layout

	int tipo = 0;
\end_layout

\begin_layout Plain Layout

	char *auxiliar; //string auxiliar
\end_layout

\begin_layout Plain Layout

	int entero; //entero auxiliar
\end_layout

\begin_layout Plain Layout

	int biciesto = 0; //booleano de año biciesto
\end_layout

\begin_layout Plain Layout

	//Asignar el tamaño de codigo de servicio
\end_layout

\begin_layout Plain Layout

	auxiliar = (char *) calloc(sizeof(char),3);
\end_layout

\begin_layout Plain Layout

	//char patron[] = "0011234562013121216321500112345678912000000100000201312127
\backslash
n";
\end_layout

\begin_layout Plain Layout

	int index = 0;
\end_layout

\begin_layout Plain Layout

	char tmp[512];
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//establecer el rubro de transaccion
\end_layout

\begin_layout Plain Layout

	for(contcar=0 ; contcar <=2; contcar++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		string[contcar] = patron[index++]; //lectura del caracter
\end_layout

\begin_layout Plain Layout

		strcat(auxiliar, string+contcar); //concatenacion en el auxiliar
\end_layout

\begin_layout Plain Layout

		if((string[contcar] != '0') && contcar <= 1)
\end_layout

\begin_layout Plain Layout

			return INVALID_COD_SERV;//CODIFICAR ERROR Y SALIR DE LA FUNCION.
 ERROR EN LOS DOS PRIMEROS DIGITOS DEL SERVICIO.	
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//****CONTROLAR QUE TIPO SEA UN NUMERO VALIDO DE SERVICIO***** SI NO ES
 VALIDO SALIR!!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	tipo = atoi(string+2);	//definir el tipo de servicio
\end_layout

\begin_layout Plain Layout

	//printf("Tipo:%d
\backslash
n",tipo);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	servicio->codser = (char *)calloc(sizeof(char),3); //Asignar tamaño al
 codigo de servicio
\end_layout

\begin_layout Plain Layout

	strcpy(servicio->codser, auxiliar); // Asignar el valor del auxiliar al
 codigo de servicio
\end_layout

\begin_layout Plain Layout

	//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

	//printf("codser: %s
\backslash
n", servicio->codser);
\end_layout

\begin_layout Plain Layout

	free(auxiliar); //liberar el auxiliar
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//establecer el tamaño del auxiliar al de transaccion
\end_layout

\begin_layout Plain Layout

	auxiliar = (char *)calloc(sizeof(char),6);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//establecer el numero de transaccion
\end_layout

\begin_layout Plain Layout

	for(contcar=0 ; contcar <=5; contcar++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		string[3+contcar] = patron[index++]; //lectura del caracter
\end_layout

\begin_layout Plain Layout

		strcat(auxiliar,string+3+contcar); //concatenación en el auxiliar
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	servicio->numtran = atoi(auxiliar); //se convierte el string de transacción
 a int y se asigna al numero de transaccion del servicio
\end_layout

\begin_layout Plain Layout

	//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

	free(auxiliar); //se libera el auxiliar
\end_layout

\begin_layout Plain Layout

	//printf("numtran: %d
\backslash
n", servicio->numtran);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Asignar el tamaño del auxiliar a fechahora
\end_layout

\begin_layout Plain Layout

	auxiliar = (char *)calloc(sizeof(char),14);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Asignar el tamano del fecharhora del Servicio
\end_layout

\begin_layout Plain Layout

	servicio->fechahora = (char *)calloc(sizeof(char),14);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//establecer la fecha de la transaccion
\end_layout

\begin_layout Plain Layout

		for(contcar=0 ; contcar<=13; contcar++)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			string[9+contcar] = patron[index++];//lectura del caracter
\end_layout

\begin_layout Plain Layout

			strcat(auxiliar, string+9+contcar);//concatenacion en el auxiliar
\end_layout

\begin_layout Plain Layout

			if(contcar == 3) //ya se leyo el año completo
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				entero = atoi(auxiliar); //convertir el char año a entero
\end_layout

\begin_layout Plain Layout

				//printf("%d
\backslash
n", entero);	
\end_layout

\begin_layout Plain Layout

				if(entero < 2013) 
\end_layout

\begin_layout Plain Layout

					return INVALID_YEAR;
\end_layout

\begin_layout Plain Layout

				if((entero%4 == 0) && (entero%100 != 0) || (entero%400 == 0)) //verificacion
 de año biciesto
\end_layout

\begin_layout Plain Layout

					biciesto = 1; //año biciesto
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if(contcar == 7) //ya se leyo el mes y el dia completo
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				entero = (string[13]-'0')*10 + (string[14]-'0'); //asignar el mes a
 entero
\end_layout

\begin_layout Plain Layout

				if(entero > 12 || entero < 1)
\end_layout

\begin_layout Plain Layout

				return INVALID_MONTH;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			if((entero == 1) || (entero == 3) || (entero == 5) || (entero == 7) ||
 (entero == 8) || (entero == 10) || (entero ==12)) // si el mes tiene 31
 dias
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				entero = (string[15]-'0')*10 + (string[16]-'0');
\end_layout

\begin_layout Plain Layout

				if((entero < 1) || (entero > 31))
\end_layout

\begin_layout Plain Layout

					return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			else if((entero == 4) || (entero == 6) || (entero == 9) || (entero ==
 11)) //si el mes tiene 30 dias
\end_layout

\begin_layout Plain Layout

				{	
\end_layout

\begin_layout Plain Layout

					entero = (string[15]-'0')*10 + (string[16]-'0');
\end_layout

\begin_layout Plain Layout

					if((entero < 1) || (entero > 30))
\end_layout

\begin_layout Plain Layout

						return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			else if(biciesto == 0) //si es febrero y el año NO es biciesto
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					entero = (string[15]-'0')*10 + (string[16]-'0');
\end_layout

\begin_layout Plain Layout

					if((entero < 1) || (entero > 28))
\end_layout

\begin_layout Plain Layout

						return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			else //si el año es biciesto y es febrero
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				entero = (string[15]-'0')*10 + (string[16]-'0');
\end_layout

\begin_layout Plain Layout

				if((entero < 1) || (entero > 29))
\end_layout

\begin_layout Plain Layout

					return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}		
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	entero = (string[17]-'0')*10 + (string[18]-'0');
\end_layout

\begin_layout Plain Layout

	if((entero > 24) || (entero < 1)) // verificar si la hora es valida
\end_layout

\begin_layout Plain Layout

		return INVALID_HOUR;
\end_layout

\begin_layout Plain Layout

	entero = (string[19]-'0')*10 + (string[20]-'0');
\end_layout

\begin_layout Plain Layout

	if((entero > 59) || (entero < 0)) //verificar si los minutos son validos
\end_layout

\begin_layout Plain Layout

		return INVALID_MIN;
\end_layout

\begin_layout Plain Layout

	entero = (string[21]-'0')*10 + (string[22]-'0');
\end_layout

\begin_layout Plain Layout

	if((entero > 59) || (entero < 0)) //verificar si los segundos son validos
\end_layout

\begin_layout Plain Layout

		return INVALID_SEC;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//asignar la fechahora del servicio
\end_layout

\begin_layout Plain Layout

	strcpy(servicio->fechahora, auxiliar);
\end_layout

\begin_layout Plain Layout

	//liberar auxiliar
\end_layout

\begin_layout Plain Layout

	//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

	free(auxiliar);
\end_layout

\begin_layout Plain Layout

	//printf("fechahora: %s
\backslash
n", servicio->fechahora);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	switch (tipo)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			case 1:
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al tipo de factura
\end_layout

\begin_layout Plain Layout

				servicio->tipofact = (char *)calloc(sizeof(char),3);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),3);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//printf("Agua
\backslash
n");
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 2; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[23+contcar] = patron[index++];//lectura del caracter
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+23+contcar);//concatenacion en el auxiliar
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//asignar el tipo de factura
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->tipofact, auxiliar);
\end_layout

\begin_layout Plain Layout

				//liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("tipofact: %s
\backslash
n", servicio->tipofact);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//Asignar recursos al comprobante
\end_layout

\begin_layout Plain Layout

				servicio->comprobante = (char *)calloc(sizeof(char),11);
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),11);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 10; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[26+contcar] = patron[index++]; //lectura del caracter
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+26+contcar); //concatenacion en el auxiliar
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

				//asignar el comprobante
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->comprobante, auxiliar);
\end_layout

\begin_layout Plain Layout

				//liberar auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Comprobante: %s
\backslash
n", servicio->comprobante);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),12);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 11; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[37+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+37+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el monto
\end_layout

\begin_layout Plain Layout

				servicio->monto = atoi(auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Monto: %d
\backslash
n", servicio->monto);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar recursos a Vencimiento
\end_layout

\begin_layout Plain Layout

				servicio->vencimiento = (char *)calloc(sizeof(char),8);
\end_layout

\begin_layout Plain Layout

				//Asignar recursos a Auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),8);
\end_layout

\begin_layout Plain Layout

				//Establecer que NO es año biciesto
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 7; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[49+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+49+contcar);
\end_layout

\begin_layout Plain Layout

					//printf("contcar=%d
\backslash
naux=%s
\backslash
n", contcar, auxiliar);
\end_layout

\begin_layout Plain Layout

					if(contcar == 3) //ya se leyo el año completo
\end_layout

\begin_layout Plain Layout

					{
\end_layout

\begin_layout Plain Layout

						entero = atoi(auxiliar); //convertir el char año a entero
\end_layout

\begin_layout Plain Layout

						if(entero < 2013)
\end_layout

\begin_layout Plain Layout

							return INVALID_YEAR;
\end_layout

\begin_layout Plain Layout

						if((entero%4 == 0) && (entero%100 != 0) || (entero%400 == 0)) //verificaci
on de año biciesto
\end_layout

\begin_layout Plain Layout

							biciesto = 1; //año biciesto
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					if(contcar == 7) //ya se leyo el mes y el dia completo
\end_layout

\begin_layout Plain Layout

					{
\end_layout

\begin_layout Plain Layout

						entero = (string[53]-'0')*10 + (string[54]-'0'); //asignar el mes
 a entero
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

						if(entero > 12 || entero < 1)
\end_layout

\begin_layout Plain Layout

							return INVALID_MONTH;
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

						if((entero == 1) || (entero == 3) || (entero == 5) || (entero == 7)
 || (entero == 8) || (entero == 10) || (entero ==12)) // si el mes tiene
 31 dias
\end_layout

\begin_layout Plain Layout

						{
\end_layout

\begin_layout Plain Layout

							entero = (string[55]-'0')*10 + (string[56]-'0'); //asignar el mes
 a entero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

							if((entero < 1) || (entero > 31))
\end_layout

\begin_layout Plain Layout

								return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

						else if((entero == 4) || (entero == 6) || (entero == 9) || (entero
 == 11)) //si el mes tiene 30 dias
\end_layout

\begin_layout Plain Layout

						{	
\end_layout

\begin_layout Plain Layout

							entero = (string[55]-'0')*10 + (string[56]-'0'); //asignar el mes
 a entero
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

							if((entero < 1) || (entero > 30))
\end_layout

\begin_layout Plain Layout

								return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

						else if(biciesto == 0) //si es febrero y el año NO es biciesto
\end_layout

\begin_layout Plain Layout

						{
\end_layout

\begin_layout Plain Layout

							entero = (string[55]-'0')*10 + (string[56]-'0'); //asignar el mes
 a entero
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

							if((entero < 1) || (entero > 28))
\end_layout

\begin_layout Plain Layout

								return -15;
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

						else //si el año es biciesto y es febrero
\end_layout

\begin_layout Plain Layout

						{
\end_layout

\begin_layout Plain Layout

							entero = (string[55]-'0')*10 + (string[56]-'0'); //asignar el mes
 a entero
\end_layout

\begin_layout Plain Layout

							if((entero < 1) || (entero > 29))
\end_layout

\begin_layout Plain Layout

								return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

						}
\end_layout

\begin_layout Plain Layout

					}		
\end_layout

\begin_layout Plain Layout

				}		
\end_layout

\begin_layout Plain Layout

				//Asignar el Vencimiento
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->vencimiento, auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Vencimiento: %s
\backslash
n", servicio->vencimiento);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Obtener el digito verificador
\end_layout

\begin_layout Plain Layout

				string[57] = patron[index++];
\end_layout

\begin_layout Plain Layout

				servicio->verificador = atoi(string+57);
\end_layout

\begin_layout Plain Layout

				//printf("Verificador: %d
\backslash
n
\backslash
n", servicio->verificador);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				servicio->prefijo = "0";
\end_layout

\begin_layout Plain Layout

				servicio->numero = "0";
\end_layout

\begin_layout Plain Layout

				servicio->nummed = 0;
\end_layout

\begin_layout Plain Layout

				servicio->abonado = "0";
\end_layout

\begin_layout Plain Layout

				servicio->mensaje = "0";
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			case 2:
\end_layout

\begin_layout Plain Layout

				//printf("Telefono Fijo
\backslash
n");
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al prefijo
\end_layout

\begin_layout Plain Layout

				servicio->prefijo = (char *)calloc(sizeof(char),4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),4);
\end_layout

\begin_layout Plain Layout

				string[23] = patron[index++];				
\end_layout

\begin_layout Plain Layout

				strcpy(auxiliar,string+23);
\end_layout

\begin_layout Plain Layout

				for(contcar = 1; contcar <= 3; contcar++)
\end_layout

\begin_layout Plain Layout

				{	
\end_layout

\begin_layout Plain Layout

					string[23+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+23+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el prefijo
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->prefijo, auxiliar);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Prefijo: %s
\backslash
n", servicio->prefijo);
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al numero
\end_layout

\begin_layout Plain Layout

				servicio->numero = (char *)calloc(sizeof(char),7);
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),7);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 6; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[27+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+27+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el numero
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->numero, auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Numero: %s
\backslash
n", servicio->numero);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),12);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 11; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[34+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+34+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el monto
\end_layout

\begin_layout Plain Layout

				servicio->monto = atoi(auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Monto: %d
\backslash
n", servicio->monto);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				servicio->comprobante = "0";
\end_layout

\begin_layout Plain Layout

				servicio->abonado = "0";
\end_layout

\begin_layout Plain Layout

				servicio->nummed = "0";
\end_layout

\begin_layout Plain Layout

				servicio->mensaje = "0";
\end_layout

\begin_layout Plain Layout

				servicio->tipofact = "0";
\end_layout

\begin_layout Plain Layout

				servicio->vencimiento = "0";
\end_layout

\begin_layout Plain Layout

				servicio->verificador = 0;
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			case 3:
\end_layout

\begin_layout Plain Layout

				//printf("Suministro Electrico
\backslash
n");
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				servicio->nummed = (char *)calloc(sizeof(char),12);
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),12);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 14; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[23+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+23+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el numero de medidor
\end_layout

\begin_layout Plain Layout

				strcpy (servicio->nummed, auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Numero de Medidor: %d
\backslash
n", servicio->nummed);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),12);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 11; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[38+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+38+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el monto
\end_layout

\begin_layout Plain Layout

				servicio->monto = atoi(auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Monto: %d
\backslash
n", servicio->monto);
\end_layout

\begin_layout Plain Layout

				servicio->tipofact = "0";
\end_layout

\begin_layout Plain Layout

				servicio->comprobante = "0";
\end_layout

\begin_layout Plain Layout

				servicio->vencimiento = "0";
\end_layout

\begin_layout Plain Layout

				servicio->verificador = 0;
\end_layout

\begin_layout Plain Layout

				servicio->prefijo = "0";
\end_layout

\begin_layout Plain Layout

				servicio->numero = "0";
\end_layout

\begin_layout Plain Layout

				servicio->abonado = "0";
\end_layout

\begin_layout Plain Layout

				servicio->mensaje = "0";
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			case 4:
\end_layout

\begin_layout Plain Layout

				//printf("Telefono Movil
\backslash
n");
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al prefijo
\end_layout

\begin_layout Plain Layout

				servicio->prefijo = (char *)calloc(sizeof(char),4);
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),4);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 3; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[23+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+23+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el prefijo
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->prefijo, auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Prefijo: %s
\backslash
n", servicio->prefijo);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//Asignar recursos al numero
\end_layout

\begin_layout Plain Layout

				servicio->numero= (char *)calloc(sizeof(char),6);
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),6);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 5; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[27+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+27+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el numero
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->numero, auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Numero: %s
\backslash
n", servicio->numero);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),12);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 11; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[33+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+33+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el monto
\end_layout

\begin_layout Plain Layout

				servicio->monto = atoi(auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Monto: %d
\backslash
n", servicio->monto);
\end_layout

\begin_layout Plain Layout

				servicio->tipofact = "0";
\end_layout

\begin_layout Plain Layout

				servicio->comprobante = "0";
\end_layout

\begin_layout Plain Layout

				servicio->vencimiento = "0";
\end_layout

\begin_layout Plain Layout

				servicio->verificador = 0;
\end_layout

\begin_layout Plain Layout

				servicio->nummed = 0;
\end_layout

\begin_layout Plain Layout

				servicio->abonado = "0";
\end_layout

\begin_layout Plain Layout

				servicio->mensaje = "0";
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			case 5:
\end_layout

\begin_layout Plain Layout

				//printf("Cable TV
\backslash
n");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//Asignar recursos al comprobante
\end_layout

\begin_layout Plain Layout

				servicio->abonado = (char *)calloc(sizeof(char),9);
\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),9);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 8; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[23+contcar] = patron[index++]; //lectura del caracter
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+23+contcar); //concatenacion en el auxiliar
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

				//asignar el comprobante
\end_layout

\begin_layout Plain Layout

				strcpy(servicio->abonado, auxiliar);
\end_layout

\begin_layout Plain Layout

				//liberar auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Abonado: %s
\backslash
n", servicio->abonado);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

				//Asignar recursos al auxiliar
\end_layout

\begin_layout Plain Layout

				auxiliar = (char *)calloc(sizeof(char),12);
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				for(contcar = 0; contcar <= 11; contcar++)
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					string[32+contcar] = patron[index++];
\end_layout

\begin_layout Plain Layout

					strcat(auxiliar, string+32+contcar);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

				//Asignar el monto
\end_layout

\begin_layout Plain Layout

				servicio->monto = atoi(auxiliar);
\end_layout

\begin_layout Plain Layout

				//Liberar el auxiliar
\end_layout

\begin_layout Plain Layout

				//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

				free(auxiliar);
\end_layout

\begin_layout Plain Layout

				//printf("Monto: %d
\backslash
n", servicio->monto);
\end_layout

\begin_layout Plain Layout

				servicio->tipofact = "0";
\end_layout

\begin_layout Plain Layout

				servicio->comprobante = "0";
\end_layout

\begin_layout Plain Layout

				servicio->vencimiento = "0";
\end_layout

\begin_layout Plain Layout

				servicio->verificador = 0;
\end_layout

\begin_layout Plain Layout

				servicio->prefijo = "0";
\end_layout

\begin_layout Plain Layout

				servicio->numero = "0";
\end_layout

\begin_layout Plain Layout

				servicio->nummed = 0;
\end_layout

\begin_layout Plain Layout

				servicio->mensaje = "0";
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

			default:
\end_layout

\begin_layout Plain Layout

				//printf("Servicio Inexistente
\backslash
n"); // CODIFICAR ERROR Y SALIR DE LA FUNCION.
 ERROR EN EL DIGITO FINAL DEL CODIGO DE TIPO
\end_layout

\begin_layout Plain Layout

				break;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return OK;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char rev_parser(SERVICIO *servicio, char * patron)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int contcar = 0; //contador de caracteres
\end_layout

\begin_layout Plain Layout

	char string[23] = {0}; //rubro
\end_layout

\begin_layout Plain Layout

	char *auxiliar; //string auxiliar
\end_layout

\begin_layout Plain Layout

	int entero; //entero auxiliar
\end_layout

\begin_layout Plain Layout

	int biciesto = 0; //booleano de año biciesto
\end_layout

\begin_layout Plain Layout

	char *tokenPtr; //puntero para los tokens
\end_layout

\begin_layout Plain Layout

	char caracter[2]={'
\backslash
0'};
\end_layout

\begin_layout Plain Layout

	//char patron[] = "00512345620131212163215Factura incorrecta.
\backslash
n";
\end_layout

\begin_layout Plain Layout

	int index = 0;
\end_layout

\begin_layout Plain Layout

	//Asignar el tamaño de codigo de servicio
\end_layout

\begin_layout Plain Layout

	auxiliar = (char *) calloc(sizeof(char),3);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//establecer el rubro de transaccion
\end_layout

\begin_layout Plain Layout

	for(contcar=0 ; contcar <=2; contcar++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		string[contcar] = patron[index++]; //lectura del caracter
\end_layout

\begin_layout Plain Layout

		strcat(auxiliar, string+contcar); //concatenacion en el auxiliar
\end_layout

\begin_layout Plain Layout

		if((string[contcar] != '0') && contcar <= 1)
\end_layout

\begin_layout Plain Layout

			return INVALID_COD_SERV; //CODIFICAR ERROR Y SALIR DE LA FUNCION.
 ERROR EN LOS DOS PRIMEROS DIGITOS DEL SERVICIO.
\end_layout

\begin_layout Plain Layout

	}	
\end_layout

\begin_layout Plain Layout

	//****CONTROLAR QUE TIPO SEA UN NUMERO VALIDO DE SERVICIO***** SI NO ES
 VALIDO SALIR!!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	servicio->codser = (char *)calloc(sizeof(char),3); //Asignar tamaño al
 codigo de servicio
\end_layout

\begin_layout Plain Layout

	strcpy(servicio->codser, auxiliar); // Asignar el valor del auxiliar al
 codigo de servicio
\end_layout

\begin_layout Plain Layout

	//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

	//printf("codser: %s
\backslash
n", servicio->codser);
\end_layout

\begin_layout Plain Layout

	free(auxiliar); //liberar el auxiliar
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//establecer el tamaño del auxiliar al de transaccion
\end_layout

\begin_layout Plain Layout

	auxiliar = (char *)calloc(sizeof(char),6);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//establecer el numero de transaccion
\end_layout

\begin_layout Plain Layout

	for(contcar=0 ; contcar <=5; contcar++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		string[3+contcar] = patron[index++]; //lectura del caracter
\end_layout

\begin_layout Plain Layout

		strcat(auxiliar,string+3+contcar); //concatenación en el auxiliar
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	servicio->numtran = atoi(auxiliar); //se convierte el string de transacción
 a int y se asigna al numero de transaccion del servicio
\end_layout

\begin_layout Plain Layout

	//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

	free(auxiliar); //se libera el auxiliar
\end_layout

\begin_layout Plain Layout

	//printf("numtran: %d
\backslash
n", servicio->numtran);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Asignar el tamaño del auxiliar a fechahora
\end_layout

\begin_layout Plain Layout

	auxiliar = (char *)calloc(sizeof(char),14);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Asignar el tamano del fecharhora del Servicio
\end_layout

\begin_layout Plain Layout

	servicio->fechahora = (char *)calloc(sizeof(char),14);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//establecer la fecha de la transaccion
\end_layout

\begin_layout Plain Layout

	for(contcar=0 ; contcar<=13; contcar++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		string[9+contcar] = patron[index++];//lectura del caracter
\end_layout

\begin_layout Plain Layout

		strcat(auxiliar, string+9+contcar);//concatenacion en el auxiliar
\end_layout

\begin_layout Plain Layout

		if(contcar == 3) //ya se leyo el año completo
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			entero = atoi(auxiliar); //convertir el char año a entero
\end_layout

\begin_layout Plain Layout

			if(entero < 2013)
\end_layout

\begin_layout Plain Layout

				return INVALID_YEAR;
\end_layout

\begin_layout Plain Layout

			if((entero%4 == 0) && (entero%100 != 0) || (entero%400 == 0)) //verificacion
 de año biciesto
\end_layout

\begin_layout Plain Layout

				biciesto = 1; //año biciesto
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(contcar == 7) //ya se leyo el mes y el dia completo
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			entero = (string[13]-'0')*10 + (string[14]-'0'); //asignar el mes a entero
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

			if(entero > 12 || entero < 1)
\end_layout

\begin_layout Plain Layout

				return INVALID_MONTH;			
\end_layout

\begin_layout Plain Layout

			if((entero == 1) || (entero == 3) || (entero == 5) || (entero == 7) ||
 (entero == 8) || (entero == 10) || (entero ==12)) // si el mes tiene 31
 dias
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				entero = (string[15]-'0')*10 + (string[16]-'0'); //asignar el mes a
 entero
\end_layout

\begin_layout Plain Layout

				if((entero < 1) || (entero > 31))
\end_layout

\begin_layout Plain Layout

					return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			else if((entero == 4) || (entero == 6) || (entero == 9) || (entero ==
 11)) //si el mes tiene 30 dias
\end_layout

\begin_layout Plain Layout

				{	
\end_layout

\begin_layout Plain Layout

					entero = (string[15]-'0')*10 + (string[16]-'0'); //asignar el mes a
 entero
\end_layout

\begin_layout Plain Layout

					if((entero < 1) || (entero > 30))
\end_layout

\begin_layout Plain Layout

						return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			else if(biciesto == 0) //si es febrero y el año NO es biciesto
\end_layout

\begin_layout Plain Layout

				{
\end_layout

\begin_layout Plain Layout

					entero = (string[15]-'0')*10 + (string[16]-'0'); //asignar el mes a
 entero
\end_layout

\begin_layout Plain Layout

					if((entero < 1) || (entero > 28))
\end_layout

\begin_layout Plain Layout

						return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			else //si el año es biciesto y es febrero
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				entero = (string[15]-'0')*10 + (string[16]-'0'); //asignar el mes a
 entero
\end_layout

\begin_layout Plain Layout

				if((entero < 1) || (entero > 29))
\end_layout

\begin_layout Plain Layout

					return INVALID_DAY;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}		
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	entero = (string[17]-'0')*10 + (string[18]-'0'); //asignar el mes a entero
\end_layout

\begin_layout Plain Layout

	if((entero > 24) || (entero < 1)) // verificar si la hora es valida
\end_layout

\begin_layout Plain Layout

		return INVALID_HOUR;
\end_layout

\begin_layout Plain Layout

	entero = (string[19]-'0')*10 + (string[20]-'0'); //asignar el mes a entero
\end_layout

\begin_layout Plain Layout

	if((entero > 59) || (entero < 0)) //verificar si los minutos son validos
\end_layout

\begin_layout Plain Layout

		return INVALID_MIN;
\end_layout

\begin_layout Plain Layout

	entero = (string[21]-'0')*10 + (string[22]-'0'); //asignar el mes a entero
\end_layout

\begin_layout Plain Layout

	if((entero > 59) || (entero < 0)) //verificar si los segundos son validos
\end_layout

\begin_layout Plain Layout

		return INVALID_SEC;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//asignar la fechahora del servicio
\end_layout

\begin_layout Plain Layout

	strcpy(servicio->fechahora, auxiliar);
\end_layout

\begin_layout Plain Layout

	//liberar auxiliar
\end_layout

\begin_layout Plain Layout

	//printf("Auxiliar: %s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

	free(auxiliar);
\end_layout

\begin_layout Plain Layout

	//printf("fechahora: %s
\backslash
n", servicio->fechahora);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	auxiliar = (char *)calloc(sizeof(char),20);
\end_layout

\begin_layout Plain Layout

	auxiliar[0] = '
\backslash
0';
\end_layout

\begin_layout Plain Layout

	while((caracter[0] = patron[index++]) != '
\backslash
n')
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		strcat(auxiliar, caracter);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	caracter[0] = '
\backslash
0';
\end_layout

\begin_layout Plain Layout

	strcat(auxiliar, caracter);
\end_layout

\begin_layout Plain Layout

	servicio->mensaje = (char *)calloc(sizeof(char),20);
\end_layout

\begin_layout Plain Layout

	strcpy(servicio->mensaje, auxiliar);
\end_layout

\begin_layout Plain Layout

	//printf("Auxiliar:%s
\backslash
n", auxiliar);
\end_layout

\begin_layout Plain Layout

	free(auxiliar);
\end_layout

\begin_layout Plain Layout

	//printf("Mensaje:%s
\backslash
n", servicio->mensaje);
\end_layout

\begin_layout Plain Layout

	return OK;
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
utils.c
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include "coldaemon.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void writelog(int log_fd, const char * mensaje)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	pthread_mutex_lock(&lock);
\end_layout

\begin_layout Plain Layout

	write(log_fd, mensaje, strlen(mensaje));
\end_layout

\begin_layout Plain Layout

	pthread_mutex_unlock(&lock);
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void thread_add(struct thread_list **lista, int index)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if(*lista == NULL)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		*lista = (struct thread_list *)malloc(sizeof(struct thread_list));
\end_layout

\begin_layout Plain Layout

		(*lista)->thread_index = index;
\end_layout

\begin_layout Plain Layout

		(*lista)->siguiente = NULL;
\end_layout

\begin_layout Plain Layout

	}else{
\end_layout

\begin_layout Plain Layout

		struct thread_list * temp  = *lista;
\end_layout

\begin_layout Plain Layout

		while(temp->siguiente != NULL)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			temp = temp->siguiente;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		temp->siguiente = (struct thread_list *)malloc(sizeof(struct thread_list));
\end_layout

\begin_layout Plain Layout

		temp = temp->siguiente;
\end_layout

\begin_layout Plain Layout

		temp->thread_index = index;
\end_layout

\begin_layout Plain Layout

		temp->siguiente = NULL;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pthread_t * thread_get(struct thread_list *lista, int index)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if(lista == NULL)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//syslog(LOG_ERR,"[CRITICAL ERROR]thread_list llega nulo!
\backslash
n");
\end_layout

\begin_layout Plain Layout

		exit(NULL_THREAD);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	do
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		if(index == lista->thread_index)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			return &(lista->hilo);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}while(lista->siguiente != NULL && (lista = lista->siguiente) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//syslog(LOG_ERR,"No existe el hilo buscado");
\end_layout

\begin_layout Plain Layout

	return NULL;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void thread_del(struct thread_list **lista, int index)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	struct thread_list * temp = *lista;
\end_layout

\begin_layout Plain Layout

	struct thread_list * anterior = NULL;
\end_layout

\begin_layout Plain Layout

	if(*lista == NULL)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		//syslog(LOG_ERR,"No se pueden borrar los hilos");
\end_layout

\begin_layout Plain Layout

		exit(NULL_THREAD);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	do{
\end_layout

\begin_layout Plain Layout

		if(index == temp->thread_index)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			if(anterior != NULL)
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				anterior->siguiente = temp->siguiente;
\end_layout

\begin_layout Plain Layout

				
\end_layout

\begin_layout Plain Layout

			}else
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				*lista = temp->siguiente;
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			free(temp);
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		anterior = temp;
\end_layout

\begin_layout Plain Layout

	}while(temp->siguiente != NULL && (temp = temp->siguiente));
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//syslog(LOG_ERR,"No hay hilos ejecutandose
\backslash
n");
\end_layout

\begin_layout Plain Layout

	return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*generador de hash de contrasenha recibe el char ingresado por teclado
 de la contrasenha y lo hashea retornando el long hash del pass*/
\end_layout

\begin_layout Plain Layout

uint32_t hash( char * str)
\end_layout

\begin_layout Plain Layout

{         
\end_layout

\begin_layout Plain Layout

    //printf ("lk%s", &str);      
\end_layout

\begin_layout Plain Layout

    uint32_t hash = 5381;
\end_layout

\begin_layout Plain Layout

    int c;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     while (c = *str++)
\end_layout

\begin_layout Plain Layout

        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

    // printf ("asdn%s", hash);
\end_layout

\begin_layout Plain Layout

     return hash;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*recibe el puntero al archivo, el puntero al usuario y contrasenha a verificar*
/
\end_layout

\begin_layout Plain Layout

char authentication (char * acl_file, char * user, uint32_t  pass_buscado)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

       char user1[50] = {'
\backslash
0'};
\end_layout

\begin_layout Plain Layout

	char *tokenPtr;
\end_layout

\begin_layout Plain Layout

       char *pass_file;
\end_layout

\begin_layout Plain Layout

	int x = 0;
\end_layout

\begin_layout Plain Layout

       uint32_t pass1=0;
\end_layout

\begin_layout Plain Layout

		FILE * acl; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		if( ( acl = fopen(acl_file,"r") ) == NULL)
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

			syslog(LOG_ERR,"No se pudo abrir %s
\backslash
n",acl_file);
\end_layout

\begin_layout Plain Layout

			return CANT_READ_ACL; //Código de error para "No se puede leer ACL"
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

               strcpy(user1, "");//vacia la variable user1
\end_layout

\begin_layout Plain Layout

               fscanf(acl, "%s", user1);//lee una linea del archivo
\end_layout

\begin_layout Plain Layout

               pass_file=(strpbrk(user1, ":")+2);//extrae lo que encuentra
 depues de '::' pass
\end_layout

\begin_layout Plain Layout

               pass1 = atoi(pass_file);//convierte el pass string leido
 de archivo a long
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

               while (memcmp(user1,user,x)!=0 && pass1!=pass_buscado &&
 !feof(acl))
\end_layout

\begin_layout Plain Layout

               {/*si el usuario y la contrasenha no son iguales, y no es
 fin de archivo leer la siguiente linea del archivo acl*/
\end_layout

\begin_layout Plain Layout

                     fscanf(acl, "%s", user1);
\end_layout

\begin_layout Plain Layout

                     pass_file=(strpbrk(user1, ":")+2);//extrae de la linea
 user::pass lo que esta despues del :: "pass"
\end_layout

\begin_layout Plain Layout

                     pass1 = atoi(pass_file);//convierte la cadena leida
 a long para luego comparar
\end_layout

\begin_layout Plain Layout

               }
\end_layout

\begin_layout Plain Layout

               /*int memcmp(const void *s1, const void *s2, size_t n);
\end_layout

\begin_layout Plain Layout

Compara los primeros n caracteres del objeto apuntado por s1 (interpretado
 como
\end_layout

\begin_layout Plain Layout

unsigned char) con los primeros n caracteres del objeto apuntado por s2
 (interpretado
\end_layout

\begin_layout Plain Layout

como unsigned char).Devuelve 0 en caso que sean iguales*/
\end_layout

\begin_layout Plain Layout

		tokenPtr= strtok(user1,"::");
\end_layout

\begin_layout Plain Layout

               if((pass_buscado==pass1 && strcmp(tokenPtr,user)) == 0)
\end_layout

\begin_layout Plain Layout

               {/*verifica si la variable registrada el final de recorrer
 la lista de archivos es igual al usuario y contrasenha buscados para la
 autenticacion*/
\end_layout

\begin_layout Plain Layout

			return OK;
\end_layout

\begin_layout Plain Layout

               }     
\end_layout

\begin_layout Plain Layout

               else//si no es por que recorrio todo el archivo y no encontro
 coincidencias de user y pass
\end_layout

\begin_layout Plain Layout

               {
\end_layout

\begin_layout Plain Layout

			return INVALID_USER;
\end_layout

\begin_layout Plain Layout

               }
\end_layout

\begin_layout Plain Layout

                   
\end_layout

\begin_layout Plain Layout

}//fin autenticacion
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch NoChildDocument
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "biblio/Plasma"
options "biblio/alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
